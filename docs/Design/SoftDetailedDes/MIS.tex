\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{array}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{arabic}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 12, 2025 & 1.0 & Added Modules M1-M22\\
Jan 11, 2026 & 1.1 & Updated local functions\\

\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\begin{tabular}{|l|l|}
\hline
\textbf{Acronym} & \textbf{Meaning} \\ \hline
DOM & Document Object Model \\ \hline
ARIA & Accessible Rich Internet Applications \\ \hline
\end{tabular}

\vspace{1em}

\noindent
For previously defined acronyms, please refer to the SRS documentation at
\href{https://github.com/speech-buddies/VoiceBridge/blob/main/docs/SRS-Volere/SRS.pdf}{SRS}.
The acronyms listed above are newly introduced in this document.
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

This document presents the Module Interface Specifications (MIS) for VoiceBridge, a modular platform 
designed to facilitate real-time voice interaction and transcription across diverse applications. 
VoiceBridge integrates advanced speech-to-text processing, natural language understanding, 
and command execution to enable intuitive voice-driven workflows.

The system supports accessibility standards, personalized user settings, and feedback mechanisms, 
allowing both developers and end-users to interact with software efficiently and securely. 
Core capabilities include continuous audio streaming, intent interpretation, contextual command 
mapping, and encrypted storage of transcripts and user profiles.

The MIS provides detailed specifications for each module, outlining their interfaces, expected inputs 
and outputs, state management, and interactions with other components. This document complements 
the System Requirements Specification (SRS) and Module Guide (MG), offering a reference for 
implementation, testing, and integration.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at {https://github.com/speech-buddies/VoiceBridge/blob/main/docs}



\section{Notation}

The structure of the MIS for modules follows \citet{HoffmanAndStrooper1995},
with template adaptations from \citet{GhezziEtAl2003}.  
The mathematical notation used throughout this document is consistent with the
formal conventions presented in Chapter 3 of \citet{HoffmanAndStrooper1995}.
For example, the symbol := denotes multiple assignment, and conditional rules
appear in the form $(c_1 \Rightarrow r_1 \mid c_2 \Rightarrow r_2 \mid \dots \mid c_n \Rightarrow r_n)$.

This section summarizes the primitive and derived data types used by
the VoiceBridge system.

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent
\begin{tabular}{l l p{7.5cm}}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
character & char & A single UTF--8 encoded character. Used for transcript tokens, UI labels, and encoded metadata fields.\\
integer & $\mathbb{Z}$ & Integer values used for counters, timestamps, retry counts, audio frame lengths, and configuration parameters. \\
natural number & $\mathbb{N}$ & Positive integer values used for unique identifiers, session IDs, buffer sizes, and timeout values. \\
real & $\mathbb{R}$ & Numerical values used for confidence scores, normalized audio energy, contrast ratios, and timing measurements (seconds).\\
boolean & bool & Logical value in \{true, false\}. Used frequently across validation, VAD detections, policy checks, etc.\\
\bottomrule
\end{tabular}
\end{center}

\noindent
In addition to these primitive types, VoiceBridge uses several derived types relevant
to speech processing, browser automation, and interaction workflows:

\begin{itemize}
    \item \textbf{Sequence} — an ordered list of elements of the same type.  
    Used for sequences of audio frames, transcripts, UI messages, or system logs.

    \item \textbf{String} — a sequence of characters (UTF--8).  
    Used for transcripts, command text, error messages, ARIA labels, and browser actions.

    \item \textbf{Tuple} — fixed-length heterogeneous group of values.  
    Used for configuration records, model parameters, recognized intents, and command mappings.

    \item \textbf{Map / Dictionary} — key–value associations.  
    Commonly used for storing UI elements, active sessions, VAD states, feedback items, command registries, and structured metadata.

    \item \textbf{UUID} — universally unique identifier.  
    Used for session IDs, command IDs, feedback items, error events, and audit log entries.

    \item \textbf{AudioFrame} — a fixed-duration slice of PCM audio sampled at the engine’s operating rate (typically 16 kHz).  
    Used by MicrophoneManager, VADNoiseFilter, and SpeechToTextEngine.

    \item \textbf{Transcript} — structured object containing recognized text and confidence metadata.  
    Produced by the Speech-to-Text Engine and consumed by the Intent Interpreter.

    \item \textbf{Intent} — structured semantic representation of a user command.  
    Contains interpreted intent name, slots, and confidence score.

    \item \textbf{Command} — validated, executable instruction produced by CommandMapping and consumed by the Execution Layer.

    \item \textbf{BackendReq / BackendResp} — typed request/response objects exchanged with the BrowserController and automation bridge.
\end{itemize}

\noindent
Functions used by VoiceBridge are typed by input and output domains.  
Local functions are documented in each module by listing their type signatures followed by their specification.
Where relevant, imported functions (e.g., VAD filters, ASR decoders, encryption routines, browser automation calls) are abstracted using their formal types rather than implementation details.



\section{Module Decomposition}
The high-level module decomposition of the system is summarized in Table 1 of the MG document. For a comprehensive and detailed breakdown, please refer to the Module Guide (MG) document available at \href{https://github.com/speech-buddies/VoiceBridge/blob/main/docs/Design/SoftArchitecture/MG.pdf}{MG document}.

\newpage
\section{MIS of User Interface Module} \label{M1}


\textbf{Module:} UserInterface

\subsection{Uses:}
\begin{itemize}
  \item Accessibility Layer (M2) to ensure UI semantics, ARIA roles, and announcements.
  \item Feedback Display Module (M3) to present messages, prompts, and recovery options.
  \item Intent Interpreter (M5) and Command Mapping (M6) for forwarding validated user events.
  \item BrowserController / rendering engine to perform DOM updates and capture input events.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{UserInterface} & \texttt{config: UiConfig} & self & InitializationError \\ 
\texttt{receiveInput} & \texttt{event: UiEvent} & - & \texttt{InputError} \\ 
\texttt{render} & \texttt{state: UiState} & - & RenderError \\ 
\texttt{showFeedback} & \texttt{msg: FeedbackItem} & - & - \\ 
\texttt{setFocus} & \texttt{elem\_id: string} & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{currentState}: \texttt{UiState} — current layout, visible components, and active feedback.
  \item \texttt{config}: \texttt{UiConfig} — persisted UI preferences (theme, verbosity).
  \item \texttt{focus\_target}: \texttt{string | null} — element currently targeted for keyboard/screen-reader focus.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{UI\_THEME} — runtime theme selection (light/dark).
  \item \texttt{LANG} — active locale.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Browser rendering engine and event APIs are available and conform to expected semantics.
  \item Downstream modules (M4–M6) accept events in the documented formats.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{UserInterface(config)}:
\begin{itemize}
\item \textbf{transition:} Initialize \texttt{currentState} and \texttt{config}; bind to Accessibility Layer (M2) and Feedback Display (M3).
\item \textbf{output:} Initialized UI instance.
\item \textbf{exception:} \texttt{InitializationError} if required resources are unavailable.
\end{itemize}

\noindent\texttt{receiveInput(event)}:
\begin{itemize}
\item \textbf{transition:} Validate \texttt{event}; update \texttt{currentState} or forward to Intent Interpreter (M5) / Command Mapping (M6) where appropriate.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{InputError} if \texttt{event} is malformed or unsupported.
\end{itemize}

\noindent\texttt{render(state)}:
\begin{itemize}
\item \textbf{transition:} Reconcile \texttt{currentState} with \texttt{state}; update DOM/renderer; notify Accessibility Layer (M2) of attribute changes.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{RenderError} on failure.
\end{itemize}

\noindent\texttt{showFeedback(msg)}:
\begin{itemize}
  \item \textbf{transition:} Delegate presentation to Feedback Display Module (M3); ensure accessible announcement via Accessibility Layer (M2).
  \item \textbf{output:} -
  \item \textbf{exception:} -
\end{itemize}

\noindent\texttt{setFocus(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Set keyboard and screen-reader focus to element identified by \texttt{elem\_id}; update \texttt{focus\_target} state.
  \item \textbf{output:} -
  \item \textbf{exception:} \texttt{InputError} if \texttt{elem\_id} does not exist.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{apply\_config}(\texttt{UiConfig cfg}): \texttt{UiConfig} $\rightarrow$ \texttt{UiState} \\
  \textbf{Description:} \texttt{apply\_config(cfg)} returns the UI state after setting theme, verbosity, and other options to match \texttt{cfg}.

  \item \texttt{normalize\_event}(\texttt{RawUiEvent e}): \texttt{RawUiEvent} $\rightarrow$ \texttt{UiEvent} \\
  \textbf{Description:} \texttt{normalize\_event(e)} returns a standard \texttt{UiEvent} with type, target, and payload from raw event \texttt{e}.
\end{itemize}

% \begin{itemize}
%   \item \texttt{apply\_config()} — Persist \texttt{config} and apply runtime settings.
%   \item \texttt{normalize\_event(event)} — Normalize raw input events into \texttt{UiEvent} format.
% \end{itemize}

\newpage
\section{MIS of Accessibility Layer} \label{M2}
\textbf{Module:} AccessibilityLayer

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to read and modify UI elements and attributes.
  \item WCAG guidance / accessibility utilities to verify contrast, labeling, and keyboard support.
  \item Feedback Display (M3) to coordinate announcements for user messages.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{AccessibilityLayer} & \texttt{parent: UserInterface} & self & - \\ 
\texttt{applySettings} & \texttt{settings: AccessConfig} & bool & - \\ 
\texttt{announce} & \texttt{msg: string} & string & - \\ 
\texttt{validateElement} & \texttt{elem\_id: string} & \texttt{ValidationReport} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{settings: AccessConfig} — active accessibility options (font scale, contrast overrides, ARIA mappings).
  \item \texttt{live\_region\_id: string} — identifier for announcement region.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{WCAG\_LEVEL} — target conformance level (e.g., AA).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI (M1) exposes element identifiers and supports attribute updates.
  \item Localization resources exist for accessible labels when required.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{applySettings(settings)}:
\begin{itemize}
\item \textbf{transition:} Merge provided \texttt{settings} with defaults; apply text scaling, contrast adjustments, and ARIA attribute mappings via \texttt{parent}.
\item \textbf{output:} Boolean success status indicating whether settings were applied successfully.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{announce(msg)}:
\begin{itemize}
\item \textbf{transition:} Post \texttt{msg} to the live region and/or invoke screen-reader API for immediate announcement.
\item \textbf{output:} Confirmation token or status indicating the announcement was successfully scheduled or posted.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateElement(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Inspect UI element attributes (role, label, states); compute a \texttt{ValidationReport} capturing compliance with accessibility standards.
  \item \textbf{output:} \texttt{ValidationReport} object detailing any missing roles, labels, or contrast issues.
  \item \textbf{exception:} -.
\end{itemize}

% \begin{itemize}
%   \item \texttt{check\_contrast(rgb\_fg, rgb\_bg)} — Compute contrast ratio based on WCAG formula \(\frac{L_1 + 0.05}{L_2 + 0.05}\), where \(L_1\) and \(L_2\) are relative luminances of foreground and background; returns Boolean pass/fail against \texttt{WCAG\_LEVEL}.
%   \item \texttt{aria\_set(elem\_id, metadata)} — Apply ARIA role, label, and state attributes to UI elements; returns Boolean indicating success.
% \end{itemize}
\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{check\_contrast}(\texttt{rgb fg, rgb bg}): \texttt{rgb} $\times$ \texttt{rgb} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{check\_contrast(fg, bg)} $\equiv$ \(\frac{L_1 + 0.05}{L_2 + 0.05}\) $\geq$ \texttt{WCAG\_THRESHOLD} where $L_1, L_2$ are relative luminances of fg/bg (used by \texttt{validateElement})

  \item \texttt{aria\_set}(\texttt{string elemId, AccessMetadata metadata}): \texttt{string} $\times$ \texttt{AccessMetadata} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{aria\_set(elemId, metadata)} returns \texttt{true} if ARIA attributes from \texttt{metadata} are applied to element \texttt{elemId} (used by \texttt{applySettings})
\end{itemize}

\newpage
\section{MIS of Feedback Display Module}
\label{M3}

\textbf{Module:} FeedbackDisplay

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to render feedback content.
  \item Accessibility Layer (M2) to ensure feedback is announced to assistive technologies.
  \item Localization/configuration store for templated messages and user preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{FeedbackDisplay} & \texttt{parent: UserInterface} & self & - \\ 
\texttt{showMessage} & \texttt{msg: string}, \texttt{type: MsgType} & \texttt{feedbackId: UUID} & - \\ 
\texttt{clear} & - & - & - \\ 
\texttt{makeRecovery} & \texttt{feedbackId: UUID} & \texttt{RecoveryOptions} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{messages: map[UUID] to FeedbackItem} — active feedback items keyed by id.
  \item \texttt{parent: UserInterface} — reference to UI for rendering.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI is capable of rendering message templates and interactive recovery prompts.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{FeedbackDisplay(parent)}:
\begin{itemize}
  \item \textbf{transition:} attach to \texttt{parent}; initialize \texttt{messages}.
  \item \textbf{output:} initialized feedback display instance.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{showMessage(msg, type)}:
\begin{itemize}
  \item \textbf{transition:} create \texttt{FeedbackItem}, store in \texttt{messages}, render via \texttt{parent}, and trigger Accessibility (M2) announcement if type requires.
  \item \textbf{output:} \texttt{feedbackId} for later reference.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{clear()}:
\begin{itemize}
  \item \textbf{transition:} remove all entries from \texttt{messages} and update UI.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{makeRecovery(feedbackId)}:
\begin{itemize}
  \item \textbf{transition:} build interactive recovery options (buttons, suggested actions) for the feedback item.
  \item \textbf{output:} \texttt{RecoveryOptions}.
  \item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{format\_message}(\texttt{string msg, MsgType type}): \texttt{string} $\times$ \texttt{MsgType} $\rightarrow$ \texttt{FeedbackItem} \\
  \textbf{Description:} \texttt{format\_message(msg, type)} returns a \texttt{FeedbackItem} with style, icon, and metadata matching \texttt{type} for text \texttt{msg}.

  \item \texttt{schedule\_dismiss}(\texttt{UUID feedbackId, N ttl\_s}): \texttt{UUID} $\times$ \texttt{N} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{schedule\_dismiss(feedbackId, ttl\_s)} returns \texttt{true} if timer is set to remove feedback \texttt{feedbackId} after \texttt{ttl\_s} seconds.
\end{itemize}
% \begin{itemize}
%   \item \texttt{format\_message(msg, type)} — apply template, icons, and localization.
%   \item \texttt{schedule\_dismiss(feedbackId, ttl\_s)} — auto-dismiss transient messages.
% \end{itemize}

\newpage
\section{MIS of Speech-to-Text Engine}
\label{M4}

\textbf{Module:} SpeechToTextEngine

\subsection{Uses:}
\begin{itemize}
  \item Audio capture interface to receive microphone streams.
  \item Noise filtering and Voice Activity Detection (VAD) for preprocessing.
  \item Personalization/Profile store for per-user adaptation.
  \item Error Feedback (M8) and AuditLogger (M14) for reporting processing failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{SpeechToTextEngine} & \texttt{config: AsrConfig} & self & InitializationError \\ 
\texttt{processAudio} & \texttt{audioData: AudioStream} & \texttt{Transcript} & \texttt{ProcessingError} \\ 
\texttt{reset} & - & - & - \\ \hline
\texttt{validateAudioFormat} & \texttt{audioData: AudioStream} & bool & - \\ 
\texttt{validateModelReady} & - & \texttt{bool} & \texttt{ModelValidationError} \\ 
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{config: AsrConfig} — engine parameters (sample rate, frame size, thresholds).
  \item \texttt{model: AsrModel} — loaded acoustic/language models and decoder state.
  \item \texttt{audio\_buffer: AudioBuffer} — buffered input audio awaiting processing.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item None.
  % \item Input audio meets expected format and sample rate.
  % \item Model artifacts are present and validated at initialization.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{SpeechToTextEngine(config)}:
\begin{itemize}
  \item \textbf{transition:} initialize engine internals, allocate \texttt{audio\_buffer}, and load \texttt{model}.
  \item \textbf{output:} initialized engine instance.
  \item \textbf{exception:} \texttt{InitializationError} if models or resources are missing.
\end{itemize}

\noindent\texttt{processAudio(audioData)}:
\begin{itemize}
  \item \textbf{transition:} validateAudioFormat(audioData) $\wedge$ preprocess (VAD, noise suppression), extract features, decode with models, and apply personalization.
  \item \textbf{output:} \texttt{Transcript} containing recognized text and confidence metadata.
  \item \textbf{exception:} \texttt{ProcessingError} if format invalid or processing fails.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
  \item \textbf{transition:} clear \texttt{audio\_buffer} and reset decoder/model state.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateAudioFormat(audio)}:
\begin{itemize}
  \item \textbf{transition:} None
  \item \textbf{output:} \texttt{true} iff \texttt{audio.sampleRate = EXPECTED\_SAMPLE\_RATE $\wedge$ audio.format = EXPECTED\_FORMAT}
  \item \textbf{exception:} -
\end{itemize}

\noindent\texttt{validateModelReady()}:
\begin{itemize}
  \item \textbf{transition:} None
  \item \textbf{output:} \texttt{true} iff model is loaded $\wedge$ model is validated
  \item \textbf{exception:} \texttt{exc := ModelValidationError} if model files missing or corrupted
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{extract\_features}(\texttt{AudioStream audio}): \texttt{AudioStream} $\rightarrow$ \texttt{FeatureVector} \\
  \textbf{Description:} \texttt{extract\_features(audio)} returns feature vector (spectrogram, MFCCs) computed from input audio.

  \item \texttt{decode}(\texttt{FeatureVector features}): \texttt{FeatureVector} $\rightarrow$ \texttt{Transcript} \\
  \textbf{Description:} \texttt{decode(features)} returns recognized text and confidence scores from model decoding.

  \item \texttt{apply\_personalization}(\texttt{Transcript transcript, UserProfile profile}): \texttt{Transcript} $\times$ \texttt{UserProfile} $\rightarrow$ \texttt{Transcript} \\
  \textbf{Description:} \texttt{apply\_personalization(transcript, profile)} returns transcript adjusted using user profile adaptation.
\end{itemize}


\newpage
\section{MIS of Intent Interpreter}
\label{M5}

\textbf{Module:} IntentInterpreter

\subsection{Uses:}
\begin{itemize}
  \item Speech-to-Text Engine (M4) for input transcripts.
  \item Intent Schema Registry for parsing and intent extraction.
  \item Error Feedback (M8) for reporting ambiguous or failed interpretations.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{MIN\_CONFIDENCE = 0.5}
  \item \texttt{EXPECTED\_TRANSCRIPT\_FORMAT = ``text + confidence''}
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{IntentInterpreter} & - & self & InitializationError \\ 
\texttt{interpret} & \texttt{transcript: Transcript} & \texttt{Intent} & \texttt{InterpretationError} \\ 
\texttt{reset} & - & - & - \\ \hline
\texttt{validateTranscript} & \texttt{transcript: Transcript} & bool & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{intent\_schemas: IntentSchemaRegistry} — canonical intent definitions and slot schemas.
  \item \texttt{context: DialogContext} — context for multi-turn dialog and disambiguation.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item None. % Transcripts are syntactically valid and provide sufficient information for intent resolution in typical cases.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{IntentInterpreter()}:
\begin{itemize}
    \item \textbf{Transition:} Load \texttt{intent\_schemas} and initialize \texttt{context} for dialog state.
    \item \textbf{Output:} Initialized interpreter instance ready to process transcripts.
    \item \textbf{Exception:} \texttt{InitializationError} if required schema resources are missing or invalid.
\end{itemize}


\noindent\texttt{interpret(transcript)}:
\begin{itemize}
  \item \textbf{transition:} validateTranscript(transcript) $\wedge$ parse input $\wedge$ match against intent schemas $\wedge$ extract slots
  \item \textbf{output:} \texttt{Intent} object containing intent name, slots, and confidence score
  \item \textbf{exception:} \texttt{InterpretationError} if transcript invalid or no confident intent found
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
\item \textbf{transition:} Clear \texttt{context} and reset transient parsing caches.
\item \textbf{output:} Boolean flag indicating success of reset operation.
\item \textbf{exception:} -
\end{itemize}
\noindent\texttt{validateTranscript(transcript)}:
\begin{itemize}
  \item \textbf{transition:} None
  \item \textbf{output:} \texttt{true} iff \texttt{transcript.text $\neq$ $\emptyset$ $\wedge$ transcript.confidence $>$ MIN\_CONFIDENCE}
  \item \textbf{exception:} None
\end{itemize}


\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{match\_intent}(\texttt{Transcript text}): \texttt{Transcript} $\rightarrow$ \texttt{Intent} \\
  \textbf{Description:} \texttt{match\_intent(text)} returns the highest-scoring intent that matches the input transcript.

  \item \texttt{extract\_slots}(\texttt{Transcript text, Intent intent}): \texttt{Transcript} $\times$ \texttt{Intent} $\rightarrow$ \texttt{Slots} \\
  \textbf{Description:} \texttt{extract\_slots(text, intent)} returns parameter values (slots) extracted from transcript for the given intent.

% \begin{itemize}
%   \item \texttt{match\_intent(text)} — score candidate intents and return best match.
%   \item \texttt{extract\_slots(intent, text)} — extract and normalize parameter values for the matched intent.
% \end{itemize}

\newpage
\section{MIS of Command Mapping Module}
\label{M6}

\textbf{Module:} CommandMapping

\subsection{Uses:}
\begin{itemize}
  \item Intent Interpreter (M5) for structured intents.
  \item Command Registry for available executable actions and metadata.
  \item User Preferences / Policy store to apply customization and guardrails.
  \item Error Feedback (M8) for reporting mapping or policy failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{CommandMapping} & - & self & InitializationError \\ 
\texttt{mapIntent} & \texttt{intent: Intent} & \texttt{Command} & \texttt{MappingError} \\ 
\texttt{validate} & \texttt{command: Command} & \texttt{bool} & - \\ 
\texttt{reset} & - & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{command\_registry: CommandRegistry} — available commands, parameter schemas, and metadata.
  \item \texttt{preferences: UserPreferences} — mapping rules and user-specific overrides.
  \item \texttt{policy: Policy} — mapping guardrails and authorization rules.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Intent objects conform to the registered schema; command registry is current and authoritative.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\texttt{CommandMapping()}:
\begin{itemize}
  \item \textbf{transition:} Load \texttt{command\_registry}, \texttt{preferences}, and \texttt{policy} configurations.
  \item \textbf{output:} Initialized mapping instance ready to process intents.
  \item \textbf{exception:} \texttt{InitializationError} if registry or policy resources are missing or invalid.
\end{itemize}


\noindent\texttt{mapIntent(intent)}:
\begin{itemize}
\item \textbf{transition:} Select candidate commands matching the \texttt{intent}; apply \texttt{preferences} and enforce \texttt{policy} constraints; produce a validated \texttt{Command}.
\item \textbf{output:} Executable \texttt{Command} object representing the mapped device or browser action.
\item \textbf{exception:} \texttt{MappingError} if no suitable mapping exists or policy prevents execution.
\end{itemize}

\noindent\texttt{validate(command)}:
\begin{itemize}
\item \textbf{transition:} Execute guardrail checks (authorization, confirmation) against \texttt{command}.
\item \textbf{output:} \texttt{true} if \texttt{command} passes all validation criteria; otherwise \texttt{false}.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
\item \textbf{transition:} Clear internal caches and reload default configuration.
\item \textbf{output:} Boolean indicating success of the reset operation.
\item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{find\_command}(\texttt{Intent intent}): \texttt{Intent} $\rightarrow$ \texttt{Command} \\
  \textbf{Description:} \texttt{find\_command(intent)} returns the best matching command from the registry for the given intent.

  \item \texttt{apply\_preferences}(\texttt{Command cmd, UserPreferences prefs}): \texttt{Command} $\times$ \texttt{UserPreferences} $\rightarrow$ \texttt{Command} \\
  \textbf{Description:} \texttt{apply\_preferences(cmd, prefs)} returns command with parameters adjusted by user preferences.

  \item \texttt{enforce\_policy}(\texttt{Command cmd, Policy policy}): \texttt{Command} $\times$ \texttt{Policy} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{enforce\_policy(cmd, policy)} returns \texttt{true} if command passes all policy checks.
\end{itemize}
% \begin{itemize}
%   \item \texttt{find\_command(intent)} — return candidate commands and ranking.
%   \item \texttt{apply\_preferences(command)} — adapt parameters per user preferences.
%   \item \texttt{enforce\_policy(command)} — apply policy and authorization constraints.
% \end{itemize}


\newpage
\section{MIS of Command Execution Layer} \label{M7}
\textbf{Module:} CommandExecutionLayer

\subsection{Uses:}
\begin{itemize}
  \item BrowserController (M14) to send \texttt{BackendReq} requests and receive \texttt{BackendResp} results.
  \item Session Manager (M15) to associate \texttt{cmd\_id} with an active session (when applicable).
  \item Error Handling \& Recovery (M16) for standardized classification, retry/backoff, and compensation decisions.
  \item AuditLogger (M19) to record execution attempts, outcomes, and failures.
  \item Error Feedback (M13) to surface user-facing execution errors and recovery prompts.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{CommandExecLayer} & \texttt{backend: Client},  & self & - \\
\texttt{execute} & \texttt{cmd: ExecCmd} & \texttt{Result} & \texttt{PermissionError}, \texttt{TimeoutError} \\
\texttt{cancel} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{status} & \texttt{cmd\_id: UUID} & \texttt{ExecStatus} & \texttt{NotFoundError} \\
\texttt{validate} & \texttt{cmd: ExecCmd} & \texttt{bool} & - \\
\texttt{map\_to\_backend} & \texttt{cmd: ExecCmd} & \texttt{BackendReq} & \texttt{MappingError} \\
\texttt{rollback} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{ExecError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{pending\_q: map[UUID]$\to$ExecCtx} — commands in flight
  \item \texttt{default\_timeout\_s: int} — global timeout for executions
  \item \texttt{retries: int} — max retry attempts for transient failures
  \item \texttt{backend: Client} — handle to browser automation bridge
  \item \texttt{audit: Logger} — sink for execution logs
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{BROWSER\_BRIDGE\_URL} — connection string for automation client
  \item \texttt{EXEC\_HARD\_LIMIT\_S} — absolute upper bound on execution time
  \item \texttt{LOG\_LEVEL} — audit verbosity
\end{itemize}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}

\noindent

\noindent \texttt{CommandExecLayer}(\texttt{backend}, \texttt{timeout\_s}):
\begin{itemize}
\item transition: initialize \texttt{pending\_q}, set \texttt{default\_timeout\_s}, bind \texttt{backend}, configure \texttt{audit}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{execute}(\texttt{cmd}):
\begin{itemize}
\item transition: add to \texttt{pending\_q}; invoke \texttt{map\_to\_backend}; dispatch to \texttt{backend}; update status; remove on completion
\item output: \texttt{Result} with success flag, message, and optional payload
\item exception: \texttt{PermissionError} if disallowed; \texttt{TimeoutError} if exceeds limits; \texttt{ExecError} on backend failure
\end{itemize}

\noindent \texttt{cancel}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: signal cancellation to backend; mark context as cancelled; remove from \texttt{pending\_q}
\item output: \texttt{true} if cancelled; otherwise \texttt{false}
\item exception: \texttt{NotFoundError} if \texttt{cmd\_id} not tracked
\end{itemize}

\noindent \texttt{status}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: none
\item output: \texttt{ExecStatus} in \{\texttt{queued}, \texttt{running}, \texttt{succeeded}, \texttt{failed}, \texttt{cancelled}\}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{validate}(\texttt{cmd}):
\begin{itemize}
\item transition: none
\item output: \texttt{true} iff command matches allowed action set and guardrails (e.g., requires-confirmation flags met)
\item exception: -
\end{itemize}

\noindent \texttt{map\_to\_backend}(\texttt{cmd}):
\begin{itemize}
\item transition: none
\item output: \texttt{BackendReq} (normalized request for the bridge)
\item exception: \texttt{MappingError} if no mapping exists
\end{itemize}

\noindent \texttt{rollback}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: attempt compensating operation (e.g., reopen tab, revert text entry)
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{ExecError} if rollback fails
\end{itemize}

% \subsubsection{Local Functions}

% \begin{itemize}
%   \item \texttt{start\_timer(ctx)} — begin timeout tracking on a context
%   \item \texttt{complete(ctx, result)} — finalize status, log, and cleanup
%   \item \texttt{is\_allowed(cmd)} — check guardrails and policy
%   \item \texttt{retryable(err)} — decide if backend error can be retried
%   \item \texttt{to\_backend(payload)} — format request for bridge
% \end{itemize}
\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{start\_timer}(\texttt{ExecCtx ctx}): \texttt{ExecCtx} $\rightarrow$ \texttt{Timer} \\
  \textbf{Description:} \texttt{start\_timer(ctx)} returns timer object that tracks timeout for execution context \texttt{ctx}.

  \item \texttt{complete}(\texttt{ExecCtx ctx, Result result}): \texttt{ExecCtx} $\times$ \texttt{Result} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{complete(ctx, result)} returns \texttt{true} if execution context is finalized and cleaned up.

  \item \texttt{is\_allowed}(\texttt{ExecCmd cmd}): \texttt{ExecCmd} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{is\_allowed(cmd)} returns \texttt{true} if command passes guardrails and policy checks.

  \item \texttt{retryable}(\texttt{Error err}): \texttt{Error} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{retryable(err)} returns \texttt{true} if error type can be safely retried.

  \item \texttt{to\_backend}(\texttt{ExecCmd cmd}): \texttt{ExecCmd} $\rightarrow$ \texttt{BackendReq} \\
  \textbf{Description:} \texttt{to\_backend(cmd)} returns normalized backend request for browser bridge.
\end{itemize}

\section{MIS of Error Feedback} \label{M8}
\textbf{Module:} ErrorFeedback

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) and Feedback Display Module (M3) to render notifications and recovery prompts.
  \item Accessibility Layer (M2) to ensure error messages and prompts are announced accessibly.
  \item Error Handling \& Recovery (M16) to standardize error classification and map internal errors to user-facing recovery options.
  \item AuditLogger (M19) to record error events and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ErrorFeedback} & \texttt{notifier: UiClient} & self & - \\
\texttt{show\_error} & \texttt{code: string}, \texttt{detail: string} & - & - \\
\texttt{show\_recovery} & \texttt{cmd\_id: UUID}, \texttt{options: string list} & - & - \\
\texttt{dismiss} & \texttt{feedback\_id: UUID} & \texttt{bool} & - \\
\texttt{log} & \texttt{event: ErrorEvent} & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{active: map[UUID] to FeedbackItem} — currently visible items
  \item \texttt{notifier: UiClient} — handle to UI notifications
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{DEFAULT\_LANG} — fallback locale
  \item \texttt{ERROR\_COPY\_PATH} — message templates location
\end{itemize}

\subsubsection{Assumptions}

UI client is available and permitted to display notifications.

\subsubsection{Access Routine Semantics}

\noindent \texttt{ErrorFeedback}(\texttt{notifier}):
\begin{itemize}
\item transition: initialize \texttt{active}; bind \texttt{notifier}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{show\_error}(\texttt{code}, \texttt{detail}):
\begin{itemize}
\item transition: create and register a feedback item in \texttt{active}; display via \texttt{notifier}
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{show\_recovery}(\texttt{cmd\_id}, \texttt{options}):
\begin{itemize}
\item transition: render recovery prompt with provided options
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{dismiss}(\texttt{feedback\_id}):
\begin{itemize}
\item transition: remove from \texttt{active}; instruct UI to hide
\item output: \texttt{true} if removed; otherwise \texttt{false}
\item exception: -
\end{itemize}

\noindent \texttt{log}(\texttt{event}):
\begin{itemize}
\item transition: write event to audit log
\item output: -
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{format\_error\_message}(\texttt{string code, string detail}): \texttt{string} $\times$ \texttt{string} $\rightarrow$ \texttt{string} \\
  \textbf{Description:} \texttt{format\_error\_message(code, detail)} returns concise user-facing error message combining code and detail.

  \item \texttt{make\_recovery}(\texttt{string list options}): \texttt{string list} $\rightarrow$ \texttt{RecoveryOptions} \\
  \textbf{Description:} \texttt{make\_recovery(options)} returns recovery prompt with clickable recovery options list.
\end{itemize}

% \begin{itemize}
%   \item \texttt{format\_message(code, detail)} — produce a concise message
%   \item \texttt{make\_recovery(options)} — build prompt content
% \end{itemize}

\section{MIS of BrowserController} \label{M9}
\textbf{Module:} BrowserController

\subsection{Uses}
\begin{itemize}
  \item Credential Manager (M20) to obtain/validate authentication material required to call the controller endpoint (when applicable).
  \item Error Handling \& Recovery (M16) to standardize timeout/retry decisions and error classification for transport failures.
  \item AuditLogger (M19) to record request/response summaries, failures, and timeouts.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{BrowserController} & \texttt{bridge: Client, timeout\_s: N} & self & -- \\
\texttt{send} & \texttt{req: BackendReq} & \texttt{BackendResp} & \texttt{TimeoutError}, \texttt{TransportError} \\
\texttt{get\_status} & \texttt{cmd\_id: UUID} & \texttt{ExecStatus} & \texttt{NotFoundError} \\
\texttt{cancel} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{open\_session} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{TransportError} \\
\texttt{close\_session} & \texttt{session\_id: SessionId} & \texttt{bool} & \texttt{TransportError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{bridge: Client} — transport to the browser controller
  \item \texttt{default\_timeout\_s: int} — call timeout
  \item \texttt{sessions: set[SessionId]} — open sessions
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{BROWSER\_BRIDGE\_URL} — endpoint for the controller
\end{itemize}

\subsubsection{Assumptions}

Controller endpoint is reachable and authenticated.

\subsubsection{Access Routine Semantics}

\noindent \texttt{BrowserController}(\texttt{bridge}, \texttt{timeout\_s}):
\begin{itemize}
\item transition: set \texttt{bridge}, \texttt{default\_timeout\_s}, clear \texttt{sessions}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{send}(\texttt{req}):
\begin{itemize}
\item transition: none
\item output: \texttt{BackendResp} from controller
\item exception: \texttt{TimeoutError}, \texttt{TransportError} on failures
\end{itemize}

\noindent \texttt{get\_status}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{ExecStatus}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{cancel}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: signal cancellation upstream
\item output: \texttt{true} if accepted
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{open\_session}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; add to \texttt{sessions}
\item output: \texttt{SessionId}
\item exception: \texttt{TransportError} if controller rejects
\end{itemize}

\noindent \texttt{close\_session}(\texttt{session\_id}):
\begin{itemize}
\item transition: close remotely; remove from \texttt{sessions}
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{TransportError} on failure
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{with\_timeout}(\texttt{ClientCall call}): \texttt{ClientCall} $\rightarrow$ \texttt{ClientCall} \\
  \textbf{Description:} \texttt{with\_timeout(call)} returns wrapped call that fails if it exceeds timeout limit.

  \item \texttt{normalize}(\texttt{BackendResp resp}): \texttt{BackendResp} $\rightarrow$ \texttt{BackendResp} \\
  \textbf{Description:} \texttt{normalize(resp)} returns controller response with standardized fields and error codes.
\end{itemize}
% \begin{itemize}
%   \item \texttt{with\_timeout(call)} — wrap a bridge call with timeout
%   \item \texttt{normalize(resp)} — normalize controller response
% \end{itemize}


\section{MIS of Session Manager} \label{M10}
\textbf{Module:} SessionManager

\subsection{Uses}

15.2 Uses:
\begin{itemize}
  \item Storage Management Module (M17) as the persistent store/cache for session state.
  \item AuditLogger (M19) to record session lifecycle events (start/stop/expiry) and state transitions.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{SessionManager} & \texttt{store: Store}, \texttt{ttl\_s: int} & self & - \\
\texttt{start} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{StoreError} \\
\texttt{stop} & \texttt{SessionId} & \texttt{bool} & \texttt{StoreError} \\
\texttt{get} & \texttt{SessionId} & \texttt{SessionState} & \texttt{NotFoundError} \\
\texttt{attach\_command} & \texttt{SessionId}, \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{set\_state} & \texttt{SessionId}, \texttt{state: SessionState} & \texttt{bool} & \texttt{StoreError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{store: Store} — persistence for sessions
  \item \texttt{ttl\_s: int} — idle expiry threshold
  \item \texttt{index: map[SessionId] to SessionState} — in-memory cache
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SESSION\_TTL\_S} — default idle timeout
\end{itemize}

\subsubsection{Assumptions}

Store operations are atomic per session key.

\subsubsection{Access Routine Semantics}

\noindent \texttt{SessionManager}(\texttt{store}, \texttt{ttl\_s}):
\begin{itemize}
\item transition: set fields; warm cache from store if available
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{start}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; write to store; cache in \texttt{index}
\item output: \texttt{SessionId}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{stop}(\texttt{session\_id}):
\begin{itemize}
\item transition: mark closed; evict from \texttt{index}; update store
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{get}(\texttt{session\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{SessionState}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{attach\_command}(\texttt{session\_id}, \texttt{cmd\_id}):
\begin{itemize}
\item transition: append command reference to session state
\item output: \texttt{true} if attached
\item exception: \texttt{NotFoundError} if session unknown
\end{itemize}

\noindent \texttt{set\_state}(\texttt{session\_id}, \texttt{state}):
\begin{itemize}
\item transition: update state in cache and store
\item output: \texttt{true} if updated
\item exception: \texttt{StoreError} on write failure
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{now}(): $\rightarrow$ \texttt{timestamp} \\
  \textbf{Description:} \texttt{now()} returns the current system timestamp.

  \item \texttt{expired}(\texttt{SessionState state}): \texttt{SessionState} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{expired(state)} returns \texttt{true} if the session state has exceeded its idle expiry time.
\end{itemize}
% \begin{itemize}
%   \item \texttt{now()} — current timestamp
%   \item \texttt{expired(state)} — checks idle expiry
% \end{itemize}
\section{MIS of Error Handling \& Recovery Module} \label{M11}

\textbf{Module:} ErrorHandler

\subsection{Uses}

\begin{itemize}
  \item Command Execution Layer (M12) to schedule retries, trigger rollback/compensation, and query execution context.
  \item BrowserController (M14) to coordinate recovery actions involving the browser automation bridge.
  \item Session Manager (M15) to update or invalidate session state during recovery (when applicable).
  \item AuditLogger (M19) to persist error events, classifications, and recovery actions taken.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ErrorHandler} & \texttt{policy: Policy} & self & - \\
\texttt{handle} & \texttt{err: ExecError}, \texttt{ctx: ExecCtx} & \texttt{ActionResult} & - \\
\texttt{retry} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{PolicyError} \\
\texttt{compensate} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{ExecError} \\
\texttt{classify} & \texttt{err: ExecError} & \texttt{ErrorClass} & - \\
\texttt{record} & \texttt{err: ExecError}, \texttt{ctx: ExecCtx} & \texttt{UUID} & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{policy: Policy} — retry and compensation rules
  \item \texttt{history: map[UUID] to ErrorEvent} — recent errors
  \item \texttt{backoff: map[UUID] to int} — current backoff in seconds
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{MAX\_RETRIES} — hard cap for attempts
  \item \texttt{BASE\_BACKOFF\_S} — initial delay
\end{itemize}

\subsubsection{Assumptions}

Compensation actions are idempotent or guarded.

\subsubsection{Access Routine Semantics}

\noindent \texttt{ErrorHandler}(\texttt{policy}):
\begin{itemize}
\item transition: set \texttt{policy}; clear \texttt{history}, \texttt{backoff}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{handle}(\texttt{err}, \texttt{ctx}):
\begin{itemize}
\item transition: classify; decide action (retry, compensate, fail); update \texttt{history}, \texttt{backoff}
\item output: \texttt{ActionResult} describing action taken
\item exception: -
\end{itemize}

\noindent \texttt{retry}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: schedule retry with policy backoff
\item output: \texttt{true} if scheduled
\item exception: \texttt{PolicyError} if retries exhausted
\end{itemize}

\noindent \texttt{compensate}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: execute compensation; update state
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{ExecError} if compensation fails
\end{itemize}

\noindent \texttt{classify}(\texttt{err}):
\begin{itemize}
\item transition: none
\item output: \texttt{ErrorClass} such as transient, permanent, or user
\item exception: -
\end{itemize}

\noindent \texttt{record}(\texttt{err}, \texttt{ctx}):
\begin{itemize}
\item transition: persist error event; update \texttt{history}
\item output: event identifier \texttt{UUID}
\item exception: -
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{calc\_backoff}(\texttt{UUID cmd\_id}): \texttt{UUID} $\rightarrow$ \texttt{N} \\
  \textbf{Description:} \texttt{calc\_backoff(cmd\_id)} returns the next retry delay (seconds) for command \texttt{cmd\_id}.

  \item \texttt{is\_idempotent}(\texttt{UUID cmd\_id}): \texttt{UUID} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{is\_idempotent(cmd\_id)} returns \texttt{true} if command \texttt{cmd\_id} is safe for compensation/rollback.
\end{itemize}
% \begin{itemize}
%   \item \texttt{calc\_backoff(cmd\_id)} — compute next delay
%   \item \texttt{is\_idempotent(cmd\_id)} — check compensation safety
% \end{itemize}

\section{MIS of Storage Management Module}\label{M12}

\textbf{Module:} Storage Management Module 

\subsection{Uses:}
\begin{itemize}
  \item Encryption Manager (M16) for encryption/decryption at rest and in transit (R16.3).
  \item Credential Manager (M15) for authenticated access to user-specific data (R16.1).
  \item AuditLogger (M14) to record storage and retrieval events (R16.4).
  \item UserProfileManager (M13) for storing personalized ASR profiles and preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{MAX\_STORAGE\_LIMIT} = 5GB per user session (configurable).
  \item \texttt{BACKUP\_INTERVAL} = 24 hours.
  \item \texttt{RETENTION\_PERIOD} = 90 days (per R16.3 Privacy Requirements).
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{storeTranscript} & transcriptData, userID & confirmationID & StorageWriteException \\ 
\texttt{retrieveTranscript} & transcriptID, userID & transcriptData & DataNotFoundException \\ 
\texttt{backupData} & userID & backupStatus & BackupFailureException \\ 
\texttt{enforceRetentionRules} & policyConfig & summaryReport & RetentionException \\ \hline
\end{tabular}

\subsection{Semantics}
\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{storageRegistry}: maps user data identifiers to file metadata and encryption state.
  \item \texttt{backupSchedule}: list of active backups per user.
  \item \texttt{retentionPolicies}: retention rules derived from privacy configuration (R16.3).
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{DATABASE\_URL}: location of secure storage database.
  \item \texttt{CLOUD\_STORAGE\_API}: API endpoint for encrypted cloud backups.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Encryption Manager (M16) is available for encrypting all stored data.
  \item User authentication is validated by Credential Manager (M15) before access.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{storeTranscript(transcriptData, userID)}:
\begin{itemize}
  \item \textbf{transition:} Adds a new entry to \texttt{storageRegistry}, encrypts transcript data via M16, and logs the event via M14.
  \item \textbf{output:} Returns confirmation ID.
  \item \textbf{exception:} \texttt{StorageWriteException} if quota exceeded or encryption fails.
\end{itemize}

\noindent\texttt{retrieveTranscript(transcriptID, userID)}:
\begin{itemize}
  \item \textbf{output:} Returns decrypted transcript data.
  \item \textbf{exception:} \texttt{DataNotFoundException} if transcriptID not found or access denied.
\end{itemize}

\noindent\texttt{backupData(userID)}:
\begin{itemize}
  \item \textbf{transition:} Performs encrypted backup of stored data to cloud (per R16.3).
  \item \textbf{output:} Backup status (success/failure).
\end{itemize}

\noindent\texttt{enforceRetentionRules(policyConfig)}:
\begin{itemize}
  \item \textbf{transition:} Deletes expired or policy-violating entries from storage.
  \item \textbf{output:} Summary of removed or archived files.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{verifyBackupIntegrity}(\texttt{UUID backupID}): \texttt{UUID} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{verifyBackupIntegrity(backupID)} returns \texttt{true} if backup \texttt{backupID} passes integrity checks.

  \item \texttt{applyRetentionRule}(\texttt{FileMeta fileMeta}): \texttt{FileMeta} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{applyRetentionRule(fileMeta)} returns \texttt{true} if file metadata \texttt{fileMeta} should be retained by retention policy.
\end{itemize}
% \begin{itemize}
%   \item \texttt{verifyBackupIntegrity(backupID)}
%   \item \texttt{applyRetentionRule(fileMeta)}
% \end{itemize}

\section{MIS of User Profile Manager} \label{M13}

\textbf{Module:} UserProfileManager

\subsection{Uses:}
\begin{itemize}
\item Credential Manager (M15) for token validation and secure login (R16.1).
\item Encryption Manager (M16) for encrypting stored profiles (R16.3).
\item Storage Management Module (M12) for persistence.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{createProfile} & \texttt{userToken: string, initData: dict} & profileID & ProfileCreationException \\ 
\texttt{loadPreferences} & userID & preferenceData & DataNotFoundException \\ 
\texttt{saveConsent} & userID, consentFlags & status & ConsentException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
\item \texttt{profiles}: map of userID → profile metadata.
\item \texttt{preferences}: user personalization data (R12.2).
\item \texttt{consentLog}: record of consent actions (R16.3).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
\item Consent is required prior to storing personalization data (R16.3 Privacy).
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{createProfile(userToken, initData)}:
\begin{itemize}
\item \textbf{transition:} Creates encrypted user profile and saves to M12 storage.
\item \textbf{exception:} \texttt{ProfileCreationException} on invalid token.
\end{itemize}

\noindent\texttt{saveConsent(userID, consentFlags)}:
\begin{itemize}
\item \textbf{transition:} Updates consentLog.
\item \textbf{output:} Confirmation of saved consent (R16.3).
\end{itemize}


\section{MIS of AuditLogger} \label{M14}

\textbf{Module:} AuditLogger

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M16) for log encryption.
\item Credential Manager (M15) for secure log access.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{logEvent} & eventData, severity & logID & LogWriteException \\ 
\texttt{queryLogs} & filterParams, userRole & logRecords & UnauthorizedAccessException \\ 
\texttt{detectAnomaly} & recentLogs & anomalyReport & DetectionException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{logEvent(eventData, severity)}:
\begin{itemize}
\item \textbf{transition:} Writes signed and encrypted log entry per R16.4.
\end{itemize}

\noindent\texttt{detectAnomaly(recentLogs)}:
\begin{itemize}
\item \textbf{output:} Triggers OutOfScopeHandler (M17) on suspicious events.
\end{itemize}


\label{MIS:M15}

\section{MIS of Credential Manager} \label{M15}

\textbf{Module:} Credential Manager (CredentialManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M16) for secure key storage.
\item AuditLogger (M14) to record authentication attempts (R16.4).
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{authenticateUser} & \texttt{username: string, password: string} & sessionToken & AuthException \\ 
\texttt{validateToken} & \texttt{sessionToken: string} & \texttt{validity: bool} & TokenException \\ 
\texttt{rotateKeys} & scheduleID & \texttt{status: string} & KeyRotationException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{authenticateUser(username, password)}:
\begin{itemize}
\item \textbf{transition:} Validates credentials via password vault; issues signed token (R16.1).
\end{itemize}

\noindent\texttt{rotateKeys(scheduleID)}:
\begin{itemize}
\item \textbf{transition:} Calls M16 to rotate key pairs per R16.3.
\end{itemize}


\label{MIS:M16}

\section{MIS of Encryption Manager} \label{M16}

\textbf{Module:} Encryption Manager (EncryptionManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item None — foundational security service.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{encryptData} & \texttt{plainData: string, keyID: UUID} & cipherData & EncryptionException \\ 
\texttt{decryptData} & cipherData, keyID & plainData & DecryptionException \\ 
\texttt{rotateKeys} & rotationPolicy & \texttt{result: bool} & RotationFailureException \\ 
\texttt{verifyIntegrity} & dataBlob, signature & validFlag & IntegrityException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.3 (Privacy Requirements): ensures all data is encrypted at rest/in transit.
Implements R16.2 (Integrity): validates message hashes before use.


\section{MIS of OutOfScopeHandler}\label{M17}

\textbf{Module:} OutOfScopeHandler

\subsection{Uses:}
\begin{itemize}
\item AuditLogger (M14) for incident reporting (R16.4).
\item Command Mapping Module (M6) for validation of user commands.
\item Error Handling \& Recovery (M11) for rollback actions.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{validateCommand} & \texttt{commandText: string, context: dict} & validationResult & InvalidCommandException \\ 
\texttt{reportIncident} & \texttt{incidentData: dict} & reportID & ReportFailureException \\ 
\texttt{recoverState} & sessionID & \texttt{status: bool} & RecoveryException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.5 (Immunity Requirements): ensures robustness against unsafe operations.
Integrates with M14 to log anomaly-triggered safety events.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{validateCommand(commandText)}:
\begin{itemize}
\item \textbf{transition:} Compares command against whitelist (policy from config).
\end{itemize}

\noindent\texttt{recoverState(sessionID)}:
\begin{itemize}
\item \textbf{transition:} Restores safe prior system state through M11.
\end{itemize}



\section{MIS of MicrophoneManager} \label{M18}

\textbf{Module:} MicrophoneManager

\subsection{Uses:}
\begin{itemize}
\item VAD Noise Filter (M19) for downstream speech/noise classification.
\item Session Manager (M10) for tracking active input sessions.
\item AuditLogger (M14) for logging permission events or device failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{listDevices} & - & deviceList & DeviceQueryException \\ 
\texttt{startCapture} & deviceID & \texttt{status: bool} & PermissionException \\ 
\texttt{readFrame} & - & audioFrame & CaptureInactiveException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements audio acquisition requirements (FR1). Provides consistent, normalized microphone
input to subsequent modules. Integrates with M10 to maintain session continuity.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{startCapture(deviceID)}:
\begin{itemize}
\item \textbf{transition:} Initializes device stream and marks microphone as active.
\end{itemize}

\noindent\texttt{readFrame()}:
\begin{itemize}
\item \textbf{transition:} Retrieves the latest audio frame for processing.
\end{itemize}

\label{MIS:M19}

\section{MIS of VADNoiseFilter} \label{M19}

\textbf{Module:} VADNoiseFilter

\subsection{Uses:}
\begin{itemize}
\item MicrophoneManager (M18) for raw audio frames.
\item Speech-to-Text Engine (M4) for improved transcription accuracy.
\item AuditLogger (M14) for tracking confidence drops or noise anomalies.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{filterFrame} & \texttt{audioFrame: AudioFrame} & \texttt{cleanedFrame: AudioFrame} & - \\ 
\texttt{detectSpeech} & \texttt{audioFrame: AudioFrame} & \texttt{isSpeech: bool} & - \\ 
\texttt{resetState} & - & \texttt{status: bool} & - \\ \hline
\end{tabular}
\end{tabular}

\subsection{Semantics}

Supports Integrity Requirements (IR2) by reducing background noise prior to transcription.
Provides binary VAD detections for downstream timing and segmentation.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{filterFrame(frame)}:
\begin{itemize}
\item \textbf{transition:} Updates internal noise profile and returns processed audio.
\end{itemize}

\noindent\texttt{detectSpeech(frame)}:
\begin{itemize}
\item \textbf{transition:} Computes speech probability using configured thresholds.
\end{itemize}

\label{MIS:M20}

\section{MIS of PromptingModule} \label{M20}

\textbf{Module:} PromptingModule

\subsection{Uses:}
\begin{itemize}
\item Intent Interpreter (M5) for phrasing confirmations.
\item Error Feedback (M8) for generating user-facing explanations.
\item Accessibility Layer (M2) for formatting prompts according to accessibility rules.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{makePrompt} & \texttt{uiState: UiState} & \texttt{promptText: string} & - \\ 
\texttt{makeConfirm} & \texttt{intent: Intent} & \texttt{promptText: string} & - \\ 
\texttt{makeErrorPrompt} & \texttt{errorData: dict} & \texttt{promptText: string} & - \\ \hline
\end{tabular}

\subsection{Semantics}

Supports usability requirements (UH-1, UH-4) and cultural neutrality (CUL-1).
Ensures consistent phrasing across confirmations, errors, and system messages.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{makeConfirm(intent)}:
\begin{itemize}
\item \textbf{transition:} Constructs a confirmation string based on target action.
\end{itemize}

\noindent\texttt{makeErrorPrompt(errorData)}:
\begin{itemize}
\item \textbf{transition:} Builds a polite, accessible error message.
\end{itemize}

\label{MIS:M21}

\section{MIS of ModelTuner} \label{M21}

\textbf{Module:} ModelTuner

\subsection{Uses:}
\begin{itemize}
\item Data Management Layer (M12) for retrieving stored audio samples.
\item ASR Engine (M4) for updating recognition parameters.
\item AuditLogger (M14) for recording tuning events or failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{scheduleTune} & userID, dataset & jobID & TunePolicyException \\ 
\texttt{checkStatus} & jobID & status & NotFoundException \\ 
\texttt{applyModel} & userID, jobID & \texttt{success: bool} & ModelLoadException \\ \hline
\end{tabular}

\subsection{Semantics}

Supports Accuracy Requirements (PF-3) by enabling adaptive personalization for impaired speech.
Updates the user's model profile upon successful tuning.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{scheduleTune(userID, dataset)}:
\begin{itemize}
\item \textbf{transition:} Registers a tuning job with the training backend.
\end{itemize}

\noindent\texttt{applyModel(userID, jobID)}:
\begin{itemize}
\item \textbf{transition:} Loads and activates the newly tuned ASR parameters.
\end{itemize}

\label{MIS:M22}

\section{MIS of InstructionRegistry} \label{M22}

\textbf{Module:} InstructionRegistry

\subsection{Uses:}
\begin{itemize}
\item Command Mapping Module (M6) for resolving intent-to-command mappings.
\item Data Management Layer (M12) for persistent storage of registered instructions.
\item AuditLogger (M14) for tracking updates to command schemas.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{lookup} & \texttt{intent: Intent} & \texttt{instruction: Command} & \texttt{NotFoundException} \\ 
\texttt{registerInstr} & \texttt{instruction: Command} & \texttt{status: bool} & \texttt{StoreException} \\ 
\texttt{updateInstr} & id, instruction & status & StoreException \\ \hline
\end{tabular}

\subsection{Semantics}

Supports command mapping requirements (FR4) and safety guardrails (SEC-2).
Maintains the authoritative index of allowed command definitions.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{lookup(intent)}:
\begin{itemize}
\item \textbf{transition:} Retrieves matching instruction from registry.
\end{itemize}

\noindent\texttt{updateInstr(id, instruction)}:
\begin{itemize}
\item \textbf{transition:} Overwrites stored schema with the updated definition.
\end{itemize}










\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

Not applicable for this document.
% \wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

% \wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

% \input{../MIS_Reflection.tex}
\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?}  
  Writing this deliverable progressed smoothly due to effective collaboration and clear communication among team members. The team successfully maintained consistency in formatting and terminology throughout the document, resulting in a cohesive and professional presentation. Peer reviews helped identify and resolve ambiguities early, which enhanced the overall quality and clarity of the deliverable.

  \item \textbf{What pain points did you experience during this deliverable, and how did you resolve them?}  
  Some challenges arose in maintaining consistent LaTeX formatting, especially with complex tables and detailed semantic descriptions. To resolve these issues, the team adopted established LaTeX best practices and created templates to ensure uniformity. Additionally, scheduled review meetings allowed the team to discuss and fix formatting inconsistencies collaboratively.

  \item \textbf{Which of your design decisions stemmed from speaking to your client(s) or a proxy (e.g., your peers, stakeholders, potential users)? For those that were not, why, and where did they come from?}  
  Many design decisions, particularly those related to user interface and accessibility, were influenced by discussions with potential users and stakeholders. Their feedback emphasized the importance of compliance with accessibility standards and intuitive user workflows. Decisions not directly influenced by client input were grounded in recognized industry standards, prior project experience, and academic literature.

  \item \textbf{While creating the design doc, what parts of your other documents (e.g., requirements, hazard analysis, etc), if any, needed to be changed, and why?}  
  During the design process, updates were made to the requirements and hazard analysis documents to reflect clarified module responsibilities and interface definitions. For example, some interface details were refined to improve modularity and error handling based on design insights. These changes ensured alignment and consistency across all project documentation.

  \item \textbf{What are the limitations of your solution? Put another way, given unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}  
  The current solution has limitations regarding scalability and adaptability in diverse deployment scenarios. With unlimited resources, we would invest in extensive automated testing frameworks and incorporate advanced machine learning techniques for improved personalization and robustness. Additionally, comprehensive accessibility audits and user testing would be expanded to further enhance usability.

  \item \textbf{Give a brief overview of other design solutions you considered. What are the benefits and tradeoffs of those other designs compared with the chosen design? From all the potential options, why did you select the documented design? (LO\_Explores)}  
  Alternative designs considered included monolithic architectures and different modular breakdowns. Monolithic design offered simplicity but reduced maintainability and scalability. Various modular structures were explored; the chosen modular design balances separation of concerns, ease of integration, and parallel development capability. This approach was selected to optimize maintainability and accommodate future enhancements efficiently.
\end{enumerate}

\end{document}