\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{array}
\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 12, 2025 & 1.0 & Added Modules M1-M19\\
Jan 11, 2026 & 1.1 & Updated local functions\\
Jan 21, 2026 & 2.0 & Merged modules in application layer\\
Jan 28, 2026 & 2.1 & Added reflection for peer module implementation\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\begin{tabular}{|l|l|}
\hline
\textbf{Acronym} & \textbf{Meaning} \\ \hline
DOM & Document Object Model \\ \hline
ARIA & Accessible Rich Internet Applications \\ \hline
\end{tabular}

\vspace{1em}

\noindent
For previously defined acronyms, please refer to the SRS documentation at
\href{https://github.com/speech-buddies/VoiceBridge/blob/main/docs/SRS-Volere/SRS.pdf}{SRS}.
The acronyms listed above are newly introduced in this document.
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

This document presents the Module Interface Specifications (MIS) for VoiceBridge, a modular platform 
designed to facilitate real-time voice interaction and transcription across diverse applications. 
VoiceBridge integrates advanced speech-to-text processing, natural language understanding, 
and command execution to enable intuitive voice-driven workflows.

The system supports accessibility standards, personalized user settings, and feedback mechanisms, 
allowing both developers and end-users to interact with software efficiently and securely. 
Core capabilities include continuous audio streaming, intent interpretation, contextual command 
mapping, and encrypted storage of transcripts and user profiles.

The MIS provides detailed specifications for each module, outlining their interfaces, expected inputs 
and outputs, state management, and interactions with other components. This document complements 
the System Requirements Specification (SRS) and Module Guide (MG), offering a reference for 
implementation, testing, and integration.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at {https://github.com/speech-buddies/VoiceBridge/blob/main/docs}



\section{Notation}

The structure of the MIS for modules follows \citet{HoffmanAndStrooper1995},
with template adaptations from \citet{GhezziEtAl2003}.  
The mathematical notation used throughout this document is consistent with the
formal conventions presented in Chapter 3 of \citet{HoffmanAndStrooper1995}.
For example, the symbol := denotes multiple assignment, and conditional rules
appear in the form $(c_1 \Rightarrow r_1 \mid c_2 \Rightarrow r_2 \mid \dots \mid c_n \Rightarrow r_n)$.

This section summarizes the primitive and derived data types used by
the VoiceBridge system.

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent
\begin{tabular}{l l p{7.5cm}}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
character & char & A single UTF--8 encoded character. Used for transcript tokens, UI labels, and encoded metadata fields.\\
integer & $\mathbb{Z}$ & Integer values used for counters, timestamps, retry counts, audio frame lengths, and configuration parameters. \\
natural number & $\mathbb{N}$ & Positive integer values used for unique identifiers, session IDs, buffer sizes, and timeout values. \\
real & $\mathbb{R}$ & Numerical values used for confidence scores, normalized audio energy, contrast ratios, and timing measurements (seconds).\\
boolean & bool & Logical value in \{true, false\}. Used frequently across validation, VAD detections, policy checks, etc.\\
\bottomrule
\end{tabular}
\end{center}

\noindent
In addition to these primitive types, VoiceBridge uses several derived types relevant
to speech processing, browser automation, and interaction workflows:

\begin{itemize}
    \item \textbf{Sequence} — an ordered list of elements of the same type.  
    Used for sequences of audio frames, transcripts, UI messages, or system logs.

    \item \textbf{String} — a sequence of characters (UTF--8).  
    Used for transcripts, command text, error messages, ARIA labels, and browser actions.

    \item \textbf{Tuple} — fixed-length heterogeneous group of values.  
    Used for configuration records, model parameters, recognized intents, and command mappings.

    \item \textbf{Map / Dictionary} — key–value associations.  
    Commonly used for storing UI elements, active sessions, VAD states, feedback items, command registries, and structured metadata.

    \item \textbf{UUID} — universally unique identifier.  
    Used for session IDs, command IDs, feedback items, error events, and audit log entries.

    \item \textbf{AudioFrame} — a fixed-duration slice of PCM audio sampled at the engine’s operating rate (typically 16 kHz).  
    Used by MicrophoneManager, VADNoiseFilter, and SpeechToTextEngine.

    \item \textbf{Transcript} — structured object containing recognized text and confidence metadata.  
    Produced by the Speech-to-Text Engine and consumed by the Intent Interpreter.

    \item \textbf{Intent} — structured semantic representation of a user command.  
    Contains interpreted intent name, slots, and confidence score.

    \item \textbf{Command} — validated, executable instruction produced by CommandMapping and consumed by the Execution Layer.

    \item \textbf{BackendReq / BackendResp} — typed request/response objects exchanged with the BrowserController and automation bridge.
\end{itemize}

\noindent
Functions used by VoiceBridge are typed by input and output domains.  
Local functions are documented in each module by listing their type signatures followed by their specification.
Where relevant, imported functions (e.g., VAD filters, ASR decoders, encryption routines, browser automation calls) are abstracted using their formal types rather than implementation details.



\section{Module Decomposition}
The high-level module decomposition of the system is summarized in Table 1 of the MG document. For a comprehensive and detailed breakdown, please refer to the Module Guide (MG) document available at \href{https://github.com/speech-buddies/VoiceBridge/blob/main/docs/Design/SoftArchitecture/MG.pdf}{MG document}.

\newpage
\section{(M1) MIS of User Interface Module} \label{M1}


\textbf{Module:} UserInterface

\subsection{Uses:}
\begin{itemize}
  \item Accessibility Layer (M2) to ensure UI semantics, ARIA roles, and announcements.
  \item Feedback Display Module (M3) to present messages, prompts, and recovery options.
  \item Command Orchestrator (M5) for forwarding validated user events.
  \item BrowserController / rendering engine to perform DOM updates and capture input events.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{UserInterface} & \texttt{config: UiConfig} & self & InitializationError \\ 
\texttt{receiveInput} & \texttt{event: UiEvent} & - & \texttt{InputError} \\ 
\texttt{render} & \texttt{state: UiState} & - & RenderError \\ 
\texttt{showFeedback} & \texttt{msg: FeedbackItem} & - & - \\ 
\texttt{setFocus} & \texttt{elem\_id: string} & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{currentState}: \texttt{UiState} — current layout, visible components, and active feedback.
  \item \texttt{config}: \texttt{UiConfig} — persisted UI preferences (theme, verbosity).
  \item \texttt{focus\_target}: \texttt{string | null} — element currently targeted for keyboard/screen-reader focus.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{UI\_THEME} — runtime theme selection (light/dark).
  \item \texttt{LANG} — active locale.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Browser rendering engine and event APIs are available and conform to expected semantics.
  \item Downstream modules (M4–M6) accept events in the documented formats.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{UserInterface(config)}:
\begin{itemize}
\item \textbf{transition:} Initialize \texttt{currentState} and \texttt{config}; bind to Accessibility Layer (M2) and Feedback Display (M3).
\item \textbf{output:} Initialized UI instance.
\item \textbf{exception:} \texttt{InitializationError} if required resources are unavailable.
\end{itemize}

\noindent\texttt{receiveInput(event)}:
\begin{itemize}
\item \textbf{transition:} Validate \texttt{event}; update \texttt{currentState} or forward to Command Orchestrator (M5) where appropriate.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{InputError} if \texttt{event} is malformed or unsupported.
\end{itemize}

\noindent\texttt{render(state)}:
\begin{itemize}
\item \textbf{transition:} Reconcile \texttt{currentState} with \texttt{state}; update DOM/renderer; notify Accessibility Layer (M2) of attribute changes.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{RenderError} on failure.
\end{itemize}

\noindent\texttt{showFeedback(msg)}:
\begin{itemize}
  \item \textbf{transition:} Delegate presentation to Feedback Display Module (M3); ensure accessible announcement via Accessibility Layer (M2).
  \item \textbf{output:} -
  \item \textbf{exception:} -
\end{itemize}

\noindent\texttt{setFocus(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Set keyboard and screen-reader focus to element identified by \texttt{elem\_id}; update \texttt{focus\_target} state.
  \item \textbf{output:} -
  \item \textbf{exception:} \texttt{InputError} if \texttt{elem\_id} does not exist.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{apply\_config}(\texttt{UiConfig cfg}): \texttt{UiConfig} $\rightarrow$ \texttt{UiState} \\
  \textbf{Description:} \texttt{apply\_config(cfg)} returns the UI state after setting theme, verbosity, and other options to match \texttt{cfg}.

  \item \texttt{normalize\_event}(\texttt{RawUiEvent e}): \texttt{RawUiEvent} $\rightarrow$ \texttt{UiEvent} \\
  \textbf{Description:} \texttt{normalize\_event(e)} returns a standard \texttt{UiEvent} with type, target, and payload from raw event \texttt{e}.
\end{itemize}

% \begin{itemize}
%   \item \texttt{apply\_config()} — Persist \texttt{config} and apply runtime settings.
%   \item \texttt{normalize\_event(event)} — Normalize raw input events into \texttt{UiEvent} format.
% \end{itemize}

\newpage
\section{(M2) MIS of Accessibility Layer} \label{M2}
\textbf{Module:} AccessibilityLayer

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to read and modify UI elements and attributes.
  \item WCAG guidance / accessibility utilities to verify contrast, labeling, and keyboard support.
  \item Feedback Display (M3) to coordinate announcements for user messages.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{AccessibilityLayer} & \texttt{parent: UserInterface} & self & - \\ 
\texttt{applySettings} & \texttt{settings: AccessConfig} & bool & - \\ 
\texttt{announce} & \texttt{msg: string} & string & - \\ 
\texttt{validateElement} & \texttt{elem\_id: string} & \texttt{ValidationReport} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{settings: AccessConfig} — active accessibility options (font scale, contrast overrides, ARIA mappings).
  \item \texttt{live\_region\_id: string} — identifier for announcement region.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{WCAG\_LEVEL} — target conformance level (e.g., AA).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI (M1) exposes element identifiers and supports attribute updates.
  \item Localization resources exist for accessible labels when required.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{applySettings(settings)}:
\begin{itemize}
\item \textbf{transition:} Merge provided \texttt{settings} with defaults; apply text scaling, contrast adjustments, and ARIA attribute mappings via \texttt{parent}.
\item \textbf{output:} Boolean success status indicating whether settings were applied successfully.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{announce(msg)}:
\begin{itemize}
\item \textbf{transition:} Post \texttt{msg} to the live region and/or invoke screen-reader API for immediate announcement.
\item \textbf{output:} Confirmation token or status indicating the announcement was successfully scheduled or posted.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateElement(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Inspect UI element attributes (role, label, states); compute a \texttt{ValidationReport} capturing compliance with accessibility standards.
  \item \textbf{output:} \texttt{ValidationReport} object detailing any missing roles, labels, or contrast issues.
  \item \textbf{exception:} -.
\end{itemize}

% \begin{itemize}
%   \item \texttt{check\_contrast(rgb\_fg, rgb\_bg)} — Compute contrast ratio based on WCAG formula \(\frac{L_1 + 0.05}{L_2 + 0.05}\), where \(L_1\) and \(L_2\) are relative luminances of foreground and background; returns Boolean pass/fail against \texttt{WCAG\_LEVEL}.
%   \item \texttt{aria\_set(elem\_id, metadata)} — Apply ARIA role, label, and state attributes to UI elements; returns Boolean indicating success.
% \end{itemize}
\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{check\_contrast}(\texttt{rgb fg, rgb bg}): \texttt{rgb} $\times$ \texttt{rgb} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{check\_contrast(fg, bg)} $\equiv$ \(\frac{L_1 + 0.05}{L_2 + 0.05}\) $\geq$ \texttt{WCAG\_THRESHOLD} where $L_1, L_2$ are relative luminances of fg/bg (used by \texttt{validateElement})

  \item \texttt{aria\_set}(\texttt{string elemId, AccessMetadata metadata}): \texttt{string} $\times$ \texttt{AccessMetadata} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{aria\_set(elemId, metadata)} returns \texttt{true} if ARIA attributes from \texttt{metadata} are applied to element \texttt{elemId} (used by \texttt{applySettings})
\end{itemize}

\newpage
\section{(M3) MIS of Feedback Display Module}
\label{M3}

\textbf{Module:} FeedbackDisplay

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to render feedback content.
  \item Accessibility Layer (M2) to ensure feedback is announced to assistive technologies.
  \item Localization/configuration store for templated messages and user preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{FeedbackDisplay} & \texttt{parent: UserInterface} & self & - \\ 
\texttt{showMessage} & \texttt{msg: string}, \texttt{type: MsgType} & \texttt{feedbackId: UUID} & - \\ 
\texttt{clear} & - & - & - \\ 
\texttt{makeRecovery} & \texttt{feedbackId: UUID} & \texttt{RecoveryOptions} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{messages: map[UUID] to FeedbackItem} — active feedback items keyed by id.
  \item \texttt{parent: UserInterface} — reference to UI for rendering.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI is capable of rendering message templates and interactive recovery prompts.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{FeedbackDisplay(parent)}:
\begin{itemize}
  \item \textbf{transition:} attach to \texttt{parent}; initialize \texttt{messages}.
  \item \textbf{output:} initialized feedback display instance.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{showMessage(msg, type)}:
\begin{itemize}
  \item \textbf{transition:} create \texttt{FeedbackItem}, store in \texttt{messages}, render via \texttt{parent}, and trigger Accessibility (M2) announcement if type requires.
  \item \textbf{output:} \texttt{feedbackId} for later reference.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{clear()}:
\begin{itemize}
  \item \textbf{transition:} remove all entries from \texttt{messages} and update UI.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{makeRecovery(feedbackId)}:
\begin{itemize}
  \item \textbf{transition:} build interactive recovery options (buttons, suggested actions) for the feedback item.
  \item \textbf{output:} \texttt{RecoveryOptions}.
  \item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{format\_message}(\texttt{string msg, MsgType type}): \texttt{string} $\times$ \texttt{MsgType} $\rightarrow$ \texttt{FeedbackItem} \\
  \textbf{Description:} \texttt{format\_message(msg, type)} returns a \texttt{FeedbackItem} with style, icon, and metadata matching \texttt{type} for text \texttt{msg}.

  \item \texttt{schedule\_dismiss}(\texttt{UUID feedbackId, N ttl\_s}): \texttt{UUID} $\times$ \texttt{N} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{schedule\_dismiss(feedbackId, ttl\_s)} returns \texttt{true} if timer is set to remove feedback \texttt{feedbackId} after \texttt{ttl\_s} seconds.
\end{itemize}
% \begin{itemize}
%   \item \texttt{format\_message(msg, type)} — apply template, icons, and localization.
%   \item \texttt{schedule\_dismiss(feedbackId, ttl\_s)} — auto-dismiss transient messages.
% \end{itemize}
\newpage
\section{(M4) MIS of Speech-to-Text Engine}
\label{M4}

\textbf{Module:} SpeechToTextEngine

\subsection{Uses:}
\begin{itemize}
  \item Audio capture interface to receive microphone streams.
  \item Noise filtering and Voice Activity Detection (VAD) for preprocessing.
  \item Error Feedback (M6) for reporting processing failures.
  \item AuditLogger (M11) for logging processing events and errors.
  \item Command Orchestrator for integration with downstream modules.
  \item Loading ASR model for speech-to-text processing.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{EXPECTED\_SAMPLE\_RATE: int = 16000} — Expected audio sample rate in Hz.
  \item \texttt{EXPECTED\_FORMAT: str = "PCM\_16K\_MONO"} — Expected audio format.
\end{itemize}


\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabularx}{\textwidth}{|l|>{\raggedright\arraybackslash\ttfamily}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline

SpeechToTextEngine &
config: AsrConfig, model\_endpoint: str, api\_key: str, device: str, vad: VadInterface, noise\_filter: NoiseFilterInterface
& self & InitializationError \\

processAudio & audioData: AudioStream & Transcript & ProcessingError \\
reset & - & - & - \\
validateAudioFormat & audioData: AudioStream & bool & - \\
validateModelReady & - & bool & ModelValidationError \\ \hline
\end{tabularx}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{config: AsrConfig} — engine parameters (sample rate, frame size, thresholds).
  \item \texttt{model: AsrModel} — loaded acoustic/language models and decoder state.
  \item \texttt{audio\_buffer: AudioBuffer} — buffered input audio awaiting processing.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{ASR\_CLOUD\_ENDPOINT} — URL of the cloud-hosted ASR model.
  \item \texttt{ASR\_API\_KEY} — API key for authenticating with the cloud-hosted ASR model.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Input audio meets expected format and sample rate.
  \item The ASR model is accessible via the provided endpoint and API key.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{SpeechToTextEngine(config, model\_endpoint, api\_key, device, vad, noise\_filter)}:
\begin{itemize}
  \item \textbf{transition:} Initialize engine internals, allocate \texttt{audio\_buffer}, and set \texttt{model\_endpoint} and \texttt{api\_key}.
  \item \textbf{output:} Initialized engine instance.
  \item \textbf{exception:} \texttt{InitializationError} if the endpoint or API key is invalid or inaccessible.
\end{itemize}

\noindent\texttt{processAudio(audioData)}:
\begin{itemize}
  \item \textbf{transition:} Validate audio format, preprocess (VAD, noise suppression), send audio to the cloud-based ASR model via \texttt{model\_endpoint} with \texttt{api\_key}, and decode the response.
  \item \textbf{output:} \texttt{Transcript} containing recognized text and confidence metadata.
  \item \textbf{exception:} \texttt{ProcessingError} if format invalid, preprocessing fails, or the cloud model is unreachable.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
  \item \textbf{transition:} Clear \texttt{audio\_buffer}.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateAudioFormat(audio)}:
\begin{itemize}
  \item \textbf{transition:} None.
  \item \textbf{output:} \texttt{true} iff \texttt{audio.sampleRate = EXPECTED\_SAMPLE\_RATE $\wedge$ audio.format = EXPECTED\_FORMAT}.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateModelReady()}:
\begin{itemize}
  \item \textbf{transition:} None.
  \item \textbf{output:} \texttt{true} iff the cloud-based ASR model is accessible via \texttt{model\_endpoint} and the \texttt{api\_key} is valid.
  \item \textbf{exception:} \texttt{ModelValidationError} if the endpoint is unreachable or the API key is invalid.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{extract\_features(audio: AudioStream) -> FeatureVector}: Returns feature vector (e.g., spectrogram) computed from input audio.
  \item \texttt{send\_to\_cloud(features: FeatureVector) -> Transcript}: Sends the feature vector to the cloud-based ASR model using the \texttt{model\_endpoint} and \texttt{api\_key}, and returns the decoded transcript.
\end{itemize}



\newpage
\section{(M5) MIS of Command Orchestrator}
\label{M5}
\textbf{Module:} CommandOrchestrator

\subsection{Uses:}
\begin{itemize}
  \item External LLM API (e.g., GPT-4o, Claude) for natural language reasoning.
  \item User Profile Manager (M8) for personalized context and preferences.
  \item Error Feedback Module (M6) for reporting API or schema validation failures.
  \item Security Layer (M9) for managing API credentials and encryption.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{MAX\_CONTEXT\_TOKENS}: Integer defining the limit for conversation history.
  \item \texttt{COMMAND\_SCHEMA}: JSON object defining the required structure for browser commands.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{CommandOrchestrator} & - & self & InitializationError \\ 
\texttt{processTranscript} & \texttt{text: String} & \texttt{Command} & \texttt{InferenceError} \\ 
\texttt{validateSchema} & \texttt{output: String} & \texttt{bool} & - \\ 
\texttt{resetContext} & - & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{system\_prompt: String} — The core instructions and few-shot examples for the LLM.
  \item \texttt{conversation\_history: List<Message>} — The rolling buffer of recent interactions.
  \item \texttt{api\_config: Config} — Parameters including temperature, model ID, and endpoint URLs.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{LLM\_API\_KEY} — Authenticated credential for the external inference service.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item The LLM API is reachable and maintains a structured output format (JSON); the system prompt effectively constrains the model to the browser's domain.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\texttt{CommandOrchestrator()}:
\begin{itemize}
  \item \textbf{transition:} Load \texttt{system\_prompt}, \texttt{api\_config}, and initialize an empty \texttt{conversation\_history}.
  \item \textbf{output:} Initialized orchestrator instance.
  \item \textbf{exception:} \texttt{InitializationError} if API keys are missing or config is malformed.
\end{itemize}

\noindent\texttt{processTranscript(text)}:
\begin{itemize}
\item \textbf{transition:} Append \texttt{text} to \texttt{conversation\_history}; send history + \texttt{system\_prompt} to LLM; parse resulting string into a \texttt{Command} object.
\item \textbf{output:} A structured \texttt{Command} object ready for the Browser Controller.
\item \textbf{exception:} \texttt{InferenceError} if the API fails, times out, or returns a non-parsable response.
\end{itemize}

\noindent\texttt{validateSchema(output)}:
\begin{itemize}
\item \textbf{transition:} Compare the LLM's raw output against \texttt{COMMAND\_SCHEMA}.
\item \textbf{output:} \texttt{true} if the output contains all required keys (e.g., action, target, value); otherwise \texttt{false}.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{resetContext()}:
\begin{itemize}
\item \textbf{transition:} Clear the \texttt{conversation\_history} list.
\item \textbf{output:} None.
\item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{construct\_payload}(\texttt{String text}): \texttt{String} $\rightarrow$ \texttt{JSON} \\
  \textbf{Description:} Packages the system prompt and conversation history into the specific JSON format required by the external API provider.

  \item \texttt{apply\_guardrails}(\texttt{Command cmd}): \texttt{Command} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} Checks the generated command against safety policies (e.g., preventing the LLM from executing "delete\_all\_history" without confirmation).

  \item \texttt{update\_history}(\texttt{Message msg}): \texttt{Message} $\rightarrow$ \texttt{void} \\
  \textbf{Description:} Manages the context window by removing the oldest messages if \texttt{MAX\_CONTEXT\_TOKENS} is exceeded.
\end{itemize}


\section{(M6) MIS of Error Feedback} 
\label{M6}
\textbf{Module:} ErrorFeedback

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) and Feedback Display Module (M3) to render notifications and recovery prompts.
  \item Accessibility Layer (M2) to ensure error messages and prompts are announced accessibly.
  \item AuditLogger (M16) to record error events and diagnostics.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ErrorFeedback} & \texttt{notifier: UiClient} & self & - \\
\texttt{show\_error} & \texttt{code: string}, \texttt{detail: string} & - & - \\
\texttt{show\_recovery} & \texttt{cmd\_id: UUID}, \texttt{options: string list} & - & - \\
\texttt{dismiss} & \texttt{feedback\_id: UUID} & \texttt{bool} & - \\
\texttt{log} & \texttt{event: ErrorEvent} & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{active: map[UUID] to FeedbackItem} — currently visible items
  \item \texttt{notifier: UiClient} — handle to UI notifications
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{DEFAULT\_LANG} — fallback locale
  \item \texttt{ERROR\_COPY\_PATH} — message templates location
\end{itemize}

\subsubsection{Assumptions}

UI client is available and permitted to display notifications.

\subsubsection{Access Routine Semantics}

\noindent \texttt{ErrorFeedback}(\texttt{notifier}):
\begin{itemize}
\item transition: initialize \texttt{active}; bind \texttt{notifier}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{show\_error}(\texttt{code}, \texttt{detail}):
\begin{itemize}
\item transition: create and register a feedback item in \texttt{active}; display via \texttt{notifier}
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{show\_recovery}(\texttt{cmd\_id}, \texttt{options}):
\begin{itemize}
\item transition: render recovery prompt with provided options
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{dismiss}(\texttt{feedback\_id}):
\begin{itemize}
\item transition: remove from \texttt{active}; instruct UI to hide
\item output: \texttt{true} if removed; otherwise \texttt{false}
\item exception: -
\end{itemize}

\noindent \texttt{log}(\texttt{event}):
\begin{itemize}
\item transition: write event to audit log
\item output: -
\item exception: -
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{format\_error\_message}(\texttt{string code, string detail}): \texttt{string} $\times$ \texttt{string} $\rightarrow$ \texttt{string} \\
  \textbf{Description:} \texttt{format\_error\_message(code, detail)} returns concise user-facing error message combining code and detail.

  \item \texttt{make\_recovery}(\texttt{string list options}): \texttt{string list} $\rightarrow$ \texttt{RecoveryOptions} \\
  \textbf{Description:} \texttt{make\_recovery(options)} returns recovery prompt with clickable recovery options list.
\end{itemize}

% \begin{itemize}
%   \item \texttt{format\_message(code, detail)} — produce a concise message
%   \item \texttt{make\_recovery(options)} — build prompt content
% \end{itemize}

\section{(M7) MIS of BrowserController} 
\label{M7}
\textbf{Module:} BrowserController

\subsection{Uses}
\begin{itemize}
  \item Credential Manager (M17) to obtain/validate authentication material required to call the controller endpoint (when applicable).
  \item Error Feedback (M6) to standardize timeout/retry decisions and error classification for transport failures.
  \item AuditLogger (M16) to record request/response summaries, failures, and timeouts.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{BrowserController} & \texttt{bridge: Client, timeout\_s: N} & self & -- \\
\texttt{send} & \texttt{req: BackendReq} & \texttt{BackendResp} & \texttt{TimeoutError}, \texttt{TransportError} \\
\texttt{get\_status} & \texttt{cmd\_id: UUID} & \texttt{ExecStatus} & \texttt{NotFoundError} \\
\texttt{cancel} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{open\_session} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{TransportError} \\
\texttt{close\_session} & \texttt{session\_id: SessionId} & \texttt{bool} & \texttt{TransportError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{bridge: Client} — transport to the browser controller
  \item \texttt{default\_timeout\_s: int} — call timeout
  \item \texttt{sessions: set[SessionId]} — open sessions
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{BROWSER\_BRIDGE\_URL} — endpoint for the controller
\end{itemize}

\subsubsection{Assumptions}

Controller endpoint is reachable and authenticated.

\subsubsection{Access Routine Semantics}

\noindent \texttt{BrowserController}(\texttt{bridge}, \texttt{timeout\_s}):
\begin{itemize}
\item transition: set \texttt{bridge}, \texttt{default\_timeout\_s}, clear \texttt{sessions}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{send}(\texttt{req}):
\begin{itemize}
\item transition: none
\item output: \texttt{BackendResp} from controller
\item exception: \texttt{TimeoutError}, \texttt{TransportError} on failures
\end{itemize}

\noindent \texttt{get\_status}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{ExecStatus}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{cancel}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: signal cancellation upstream
\item output: \texttt{true} if accepted
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{open\_session}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; add to \texttt{sessions}
\item output: \texttt{SessionId}
\item exception: \texttt{TransportError} if controller rejects
\end{itemize}

\noindent \texttt{close\_session}(\texttt{session\_id}):
\begin{itemize}
\item transition: close remotely; remove from \texttt{sessions}
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{TransportError} on failure
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{with\_timeout}(\texttt{ClientCall call}): \texttt{ClientCall} $\rightarrow$ \texttt{ClientCall} \\
  \textbf{Description:} \texttt{with\_timeout(call)} returns wrapped call that fails if it exceeds timeout limit.

  \item \texttt{normalize}(\texttt{BackendResp resp}): \texttt{BackendResp} $\rightarrow$ \texttt{BackendResp} \\
  \textbf{Description:} \texttt{normalize(resp)} returns controller response with standardized fields and error codes.
\end{itemize}
% \begin{itemize}
%   \item \texttt{with\_timeout(call)} — wrap a bridge call with timeout
%   \item \texttt{normalize(resp)} — normalize controller response
% \end{itemize}


\section{(M8) MIS of Session Manager} \label{M8}
\textbf{Module:} SessionManager

\subsection{Uses}

15.2 Uses:
\begin{itemize}
  \item Storage Management Module (M14) as the persistent store/cache for session state.
  \item AuditLogger (M16) to record session lifecycle events (start/stop/expiry) and state transitions.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{SessionManager} & \texttt{store: Store}, \texttt{ttl\_s: int} & self & - \\
\texttt{start} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{StoreError} \\
\texttt{stop} & \texttt{SessionId} & \texttt{bool} & \texttt{StoreError} \\
\texttt{get} & \texttt{SessionId} & \texttt{SessionState} & \texttt{NotFoundError} \\
\texttt{attach\_command} & \texttt{SessionId}, \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{set\_state} & \texttt{SessionId}, \texttt{state: SessionState} & \texttt{bool} & \texttt{StoreError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{store: Store} — persistence for sessions
  \item \texttt{ttl\_s: int} — idle expiry threshold
  \item \texttt{index: map[SessionId] to SessionState} — in-memory cache
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SESSION\_TTL\_S} — default idle timeout
\end{itemize}

\subsubsection{Assumptions}

Store operations are atomic per session key.

\subsubsection{Access Routine Semantics}

\noindent \texttt{SessionManager}(\texttt{store}, \texttt{ttl\_s}):
\begin{itemize}
\item transition: set fields; warm cache from store if available
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{start}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; write to store; cache in \texttt{index}
\item output: \texttt{SessionId}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{stop}(\texttt{session\_id}):
\begin{itemize}
\item transition: mark closed; evict from \texttt{index}; update store
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{get}(\texttt{session\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{SessionState}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{attach\_command}(\texttt{session\_id}, \texttt{cmd\_id}):
\begin{itemize}
\item transition: append command reference to session state
\item output: \texttt{true} if attached
\item exception: \texttt{NotFoundError} if session unknown
\end{itemize}

\noindent \texttt{set\_state}(\texttt{session\_id}, \texttt{state}):
\begin{itemize}
\item transition: update state in cache and store
\item output: \texttt{true} if updated
\item exception: \texttt{StoreError} on write failure
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{now}(): $\rightarrow$ \texttt{timestamp} \\
  \textbf{Description:} \texttt{now()} returns the current system timestamp.

  \item \texttt{expired}(\texttt{SessionState state}): \texttt{SessionState} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{expired(state)} returns \texttt{true} if the session state has exceeded its idle expiry time.
\end{itemize}
% \begin{itemize}
%   \item \texttt{calc\_backoff(cmd\_id)} — compute next delay
%   \item \texttt{is\_idempotent(cmd\_id)} — check compensation safety
% \end{itemize}

\section{(M9) MIS of Data Management Module}\label{M9}

\textbf{Module:} Data Management Module 

\subsection{Uses:}
\begin{itemize}
  \item Encryption Manager (M13) for encryption/decryption at rest and in transit (R16.3).
  \item Credential Manager (M12) for authenticated access to user-specific data (R16.1).
  \item AuditLogger (M11) to record storage and retrieval events (R16.4).
  \item UserProfileManager (M10) for storing personalized ASR profiles and preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{MAX\_STORAGE\_LIMIT} = 5GB per user session (configurable).
  \item \texttt{BACKUP\_INTERVAL} = 24 hours.
  \item \texttt{RETENTION\_PERIOD} = 90 days (per R16.3 Privacy Requirements).
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{storeTranscript} & transcriptData, userID & confirmationID & StorageWriteException \\ 
\texttt{retrieveTranscript} & transcriptID, userID & transcriptData & DataNotFoundException \\ 
\texttt{backupData} & userID & backupStatus & BackupFailureException \\ 
\texttt{enforceRetentionRules} & policyConfig & summaryReport & RetentionException \\ \hline
\end{tabular}

\subsection{Semantics}
\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{storageRegistry}: maps user data identifiers to file metadata and encryption state.
  \item \texttt{backupSchedule}: list of active backups per user.
  \item \texttt{retentionPolicies}: retention rules derived from privacy configuration (R16.3).
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{DATABASE\_URL}: location of secure storage database.
  \item \texttt{CLOUD\_STORAGE\_API}: API endpoint for encrypted cloud backups.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Encryption Manager (M13) is available for encrypting all stored data.
  \item User authentication is validated by Credential Manager (M12) before access.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{storeTranscript(transcriptData, userID)}:
\begin{itemize}
  \item \textbf{transition:} Adds a new entry to \texttt{storageRegistry}, encrypts transcript data via M13, and logs the event via M11.
  \item \textbf{output:} Returns confirmation ID.
  \item \textbf{exception:} \texttt{StorageWriteException} if quota exceeded or encryption fails.
\end{itemize}

\noindent\texttt{retrieveTranscript(transcriptID, userID)}:
\begin{itemize}
  \item \textbf{output:} Returns decrypted transcript data.
  \item \textbf{exception:} \texttt{DataNotFoundException} if transcriptID not found or access denied.
\end{itemize}

\noindent\texttt{backupData(userID)}:
\begin{itemize}
  \item \textbf{transition:} Performs encrypted backup of stored data to cloud (per R16.3).
  \item \textbf{output:} Backup status (success/failure).
\end{itemize}

\noindent\texttt{enforceRetentionRules(policyConfig)}:
\begin{itemize}
  \item \textbf{transition:} Deletes expired or policy-violating entries from storage.
  \item \textbf{output:} Summary of removed or archived files.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{verifyBackupIntegrity}(\texttt{UUID backupID}): \texttt{UUID} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{verifyBackupIntegrity(backupID)} returns \texttt{true} if backup \texttt{backupID} passes integrity checks.

  \item \texttt{applyRetentionRule}(\texttt{FileMeta fileMeta}): \texttt{FileMeta} $\rightarrow$ \texttt{bool} \\
  \textbf{Description:} \texttt{applyRetentionRule(fileMeta)} returns \texttt{true} if file metadata \texttt{fileMeta} should be retained by retention policy.
\end{itemize}
% \begin{itemize}
%   \item \texttt{verifyBackupIntegrity(backupID)}
%   \item \texttt{applyRetentionRule(fileMeta)}
% \end{itemize}

\section{(M10) MIS of User Profile Manager} \label{M10}

\textbf{Module:} UserProfileManager

\subsection{Uses:}
\begin{itemize}
\item Credential Manager (M12) for token validation and secure login (R16.1).
\item Encryption Manager (M13) for encrypting stored profiles (R16.3).
\item Storage Management Module (M9) for persistence.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{createProfile} & \texttt{userToken: string, initData: dict} & profileID & ProfileCreationException \\ 
\texttt{loadPreferences} & userID & preferenceData & DataNotFoundException \\ 
\texttt{saveConsent} & userID, consentFlags & status & ConsentException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
\item \texttt{profiles}: map of userID → profile metadata.
\item \texttt{preferences}: user personalization data (R12.2).
\item \texttt{consentLog}: record of consent actions (R16.3).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
\item Consent is required prior to storing personalization data (R16.3 Privacy).
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{createProfile(userToken, initData)}:
\begin{itemize}
\item \textbf{transition:} Creates encrypted user profile and saves to M9 storage.
\item \textbf{exception:} \texttt{ProfileCreationException} on invalid token.
\end{itemize}

\noindent\texttt{saveConsent(userID, consentFlags)}:
\begin{itemize}
\item \textbf{transition:} Updates consentLog.
\item \textbf{output:} Confirmation of saved consent (R16.3).
\end{itemize}


\section{(M11) MIS of AuditLogger} \label{M11}

\textbf{Module:} AuditLogger

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M13) for log encryption.
\item Credential Manager (M12) for secure log access.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{logEvent} & eventData, severity & logID & LogWriteException \\ 
\texttt{queryLogs} & filterParams, userRole & logRecords & UnauthorizedAccessException \\ 
\texttt{detectAnomaly} & recentLogs & anomalyReport & DetectionException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{logEvent(eventData, severity)}:
\begin{itemize}
\item \textbf{transition:} Writes signed and encrypted log entry per R16.4.
\end{itemize}

\noindent\texttt{detectAnomaly(recentLogs)}:
\begin{itemize}
\item \textbf{output:} Triggers OutOfScopeHandler (M14) on suspicious events.
\end{itemize}



\section{(M12) MIS of Credential Manager} \label{M12}
\label{MIS:M12}

\textbf{Module:} Credential Manager (CredentialManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M13) for secure key storage.
\item AuditLogger (M11) to record authentication attempts (R16.4).
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{authenticateUser} & \texttt{username: string, password: string} & sessionToken & AuthException \\ 
\texttt{validateToken} & \texttt{sessionToken: string} & \texttt{validity: bool} & TokenException \\ 
\texttt{rotateKeys} & scheduleID & \texttt{status: string} & KeyRotationException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{authenticateUser(username, password)}:
\begin{itemize}
\item \textbf{transition:} Validates credentials via password vault; issues signed token (R16.1).
\end{itemize}

\noindent\texttt{rotateKeys(scheduleID)}:
\begin{itemize}
\item \textbf{transition:} Calls M13 to rotate key pairs per R16.3.
\end{itemize}



\section{(M13) MIS of Encryption Manager} \label{M13}
\label{MIS:M13}

\textbf{Module:} Encryption Manager (EncryptionManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item None — foundational security service.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{encryptData} & \texttt{plainData: string, keyID: UUID} & cipherData & EncryptionException \\ 
\texttt{decryptData} & cipherData, keyID & plainData & DecryptionException \\ 
\texttt{rotateKeys} & rotationPolicy & \texttt{result: bool} & RotationFailureException \\ 
\texttt{verifyIntegrity} & dataBlob, signature & validFlag & IntegrityException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.3 (Privacy Requirements): ensures all data is encrypted at rest/in transit.
Implements R16.2 (Integrity): validates message hashes before use.


\section{(M14) MIS of OutOfScopeHandler}\label{M14}

\textbf{Module:} OutOfScopeHandler

\subsection{Uses:}
\begin{itemize}
\item AuditLogger (M11) for incident reporting (R16.4).
\item Command Orchestrator (M5) for validation of user commands.
\item Error Handling \& Recovery (M11) for rollback actions.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{validateCommand} & \texttt{commandText: string, context: dict} & validationResult & InvalidCommandException \\ 
\texttt{reportIncident} & \texttt{incidentData: dict} & reportID & ReportFailureException \\ 
\texttt{recoverState} & sessionID & \texttt{status: bool} & RecoveryException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.5 (Immunity Requirements): ensures robustness against unsafe operations.
Integrates with M11 to log anomaly-triggered safety events.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{validateCommand(commandText)}:
\begin{itemize}
\item \textbf{transition:} Compares command against whitelist (policy from config).
\end{itemize}

\noindent\texttt{recoverState(sessionID)}:
\begin{itemize}
\item \textbf{transition:} Restores safe prior system state through M11.
\end{itemize}



\section{(M15) MIS of MicrophoneManager} \label{M15}

\textbf{Module:} MicrophoneManager

\subsection{Uses:}
\begin{itemize}
\item VAD Noise Filter (M16) for downstream speech/noise classification.
\item Session Manager (M8) for tracking active input sessions.
\item AuditLogger (M11) for logging permission events or device failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{listDevices} & - & deviceList & DeviceQueryException \\ 
\texttt{startCapture} & deviceID & \texttt{status: bool} & PermissionException \\ 
\texttt{readFrame} & - & audioFrame & CaptureInactiveException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements audio acquisition requirements (FR1). Provides consistent, normalized microphone
input to subsequent modules. Integrates with M8 to maintain session continuity.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{startCapture(deviceID)}:
\begin{itemize}
\item \textbf{transition:} Initializes device stream and marks microphone as active.
\end{itemize}

\noindent\texttt{readFrame()}:
\begin{itemize}
\item \textbf{transition:} Retrieves the latest audio frame for processing.
\end{itemize}

\label{MIS:M16}

\section{(M16) MIS of VADNoiseFilter} \label{M16}

\textbf{Module:} VADNoiseFilter

\subsection{Uses:}
\begin{itemize}
\item MicrophoneManager (M15) for raw audio frames.
\item Speech-to-Text Engine (M4) for improved transcription accuracy.
\item AuditLogger (M11) for tracking confidence drops or noise anomalies.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{filterFrame} & \texttt{audioFrame: AudioFrame} & \texttt{cleanedFrame: AudioFrame} & - \\ 
\texttt{detectSpeech} & \texttt{audioFrame: AudioFrame} & \texttt{isSpeech: bool} & - \\ 
\texttt{resetState} & - & \texttt{status: bool} & - \\ \hline
\end{tabular}

\subsection{Semantics}

Supports Integrity Requirements (IR2) by reducing background noise prior to transcription.
Provides binary VAD detections for downstream timing and segmentation.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{filterFrame(frame)}:
\begin{itemize}
\item \textbf{transition:} Updates internal noise profile and returns processed audio.
\end{itemize}

\noindent\texttt{detectSpeech(frame)}:
\begin{itemize}
\item \textbf{transition:} Computes speech probability using configured thresholds.
\end{itemize}

\label{MIS:M17}

\section{(M17) MIS of PromptingModule} \label{M17}

\textbf{Module:} PromptingModule

\subsection{Uses:}
\begin{itemize}
\item Command Orchestrator (M5) for phrasing confirmations.
\item Error Feedback (M6) for generating user-facing explanations.
\item Accessibility Layer (M2) for formatting prompts according to accessibility rules.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{makePrompt} & \texttt{uiState: UiState} & \texttt{promptText: string} & - \\ 
\texttt{makeConfirm} & \texttt{intent: Intent} & \texttt{promptText: string} & - \\ 
\texttt{makeErrorPrompt} & \texttt{errorData: dict} & \texttt{promptText: string} & - \\ \hline
\end{tabular}

\subsection{Semantics}

Supports usability requirements (UH-1, UH-4) and cultural neutrality (CUL-1).
Ensures consistent phrasing across confirmations, errors, and system messages.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{makeConfirm(intent)}:
\begin{itemize}
\item \textbf{transition:} Constructs a confirmation string based on target action.
\end{itemize}

\noindent\texttt{makeErrorPrompt(errorData)}:
\begin{itemize}
\item \textbf{transition:} Builds a polite, accessible error message.
\end{itemize}

\label{MIS:M18}

\section{(M18) MIS of ModelTuner} \label{M18}

\textbf{Module:} ModelTuner

\subsection{Uses:}
\begin{itemize}
\item Data Management Layer (M9) for retrieving stored audio samples.
\item ASR Engine (M4) for updating recognition parameters.
\item AuditLogger (M11) for recording tuning events or failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{scheduleTune} & userID, dataset & jobID & TunePolicyException \\ 
\texttt{checkStatus} & jobID & status & NotFoundException \\ 
\texttt{applyModel} & userID, jobID & \texttt{success: bool} & ModelLoadException \\ \hline
\end{tabular}

\subsection{Semantics}

Supports Accuracy Requirements (PF-3) by enabling adaptive personalization for impaired speech.
Updates the user's model profile upon successful tuning.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{scheduleTune(userID, dataset)}:
\begin{itemize}
\item \textbf{transition:} Registers a tuning job with the training backend.
\end{itemize}

\noindent\texttt{applyModel(userID, jobID)}:
\begin{itemize}
\item \textbf{transition:} Loads and activates the newly tuned ASR parameters.
\end{itemize}










\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

Not applicable for this document.
% \wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

% \wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

% \input{../MIS_Reflection.tex}
\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?}  
  Writing this deliverable progressed smoothly due to effective collaboration and clear communication among team members. The team successfully maintained consistency in formatting and terminology throughout the document, resulting in a cohesive and professional presentation. Peer reviews helped identify and resolve ambiguities early, which enhanced the overall quality and clarity of the deliverable.

  \item \textbf{What pain points did you experience during this deliverable, and how did you resolve them?}  
  Some challenges arose in maintaining consistent LaTeX formatting, especially with complex tables and detailed semantic descriptions. To resolve these issues, the team adopted established LaTeX best practices and created templates to ensure uniformity. Additionally, scheduled review meetings allowed the team to discuss and fix formatting inconsistencies collaboratively.

  \item \textbf{Which of your design decisions stemmed from speaking to your client(s) or a proxy (e.g., your peers, stakeholders, potential users)? For those that were not, why, and where did they come from?}  
  Many design decisions, particularly those related to user interface and accessibility, were influenced by discussions with potential users and stakeholders. Their feedback emphasized the importance of compliance with accessibility standards and intuitive user workflows. Decisions not directly influenced by client input were grounded in recognized industry standards, prior project experience, and academic literature.

  \item \textbf{While creating the design doc, what parts of your other documents (e.g., requirements, hazard analysis, etc), if any, needed to be changed, and why?}  
  During the design process, updates were made to the requirements and hazard analysis documents to reflect clarified module responsibilities and interface definitions. For example, some interface details were refined to improve modularity and error handling based on design insights. These changes ensured alignment and consistency across all project documentation.

  \item \textbf{What are the limitations of your solution? Put another way, given unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}  
  The current solution has limitations regarding scalability and adaptability in diverse deployment scenarios. With unlimited resources, we would invest in extensive automated testing frameworks and incorporate advanced machine learning techniques for improved personalization and robustness. Additionally, comprehensive accessibility audits and user testing would be expanded to further enhance usability.

  \item \textbf{Give a brief overview of other design solutions you considered. What are the benefits and tradeoffs of those other designs compared with the chosen design? From all the potential options, why did you select the documented design? (LO\_Explores)}  
  Alternative designs considered included monolithic architectures and different modular breakdowns. Monolithic design offered simplicity but reduced maintainability and scalability. Various modular structures were explored; the chosen modular design balances separation of concerns, ease of integration, and parallel development capability. This approach was selected to optimize maintainability and accommodate future enhancements efficiently.

  \item \textbf{What did you learn by implementing another team's module? Were all the details you needed in the documentation, or did you need to make assumptions, or ask the other team questions?  If your team also had another team implement one of your modules, what was this experience like?  Are there things in your documentation you could have changed to make the process go more smoothly for when an ``outsider'' completes some of the implementation?}
  Implementing the Mel Filter Module demonstrated how much a formal mathematical foundation simplifies cross-team collaboration. Because the documentation provided a specific matrix summation formula, we could translate signal processing requirements into C++ logic with very little ambiguity. We briefly struggled with the index mapping for the filterbank matrix $H$, but the provided semantic notation allowed us to resolve the structure ourselves. This experience showed that a rigorous mathematical contract reduces the need for an external implementer to make arbitrary assumptions or constantly ask the original designers for clarification.
  In contrast, having another team implement our User Profile module revealed that our specifications relied too heavily on implicit context. Since we didn't formalize the internal logic or state changes, the module's behavior wasn't immediately clear to an outsider. To make our documentation more self-contained, we should have included detailed logic in the future. This highlighted that documentation requires a much higher level of formal detail when the developer is not the original designer.



\end{enumerate}

\end{document}