\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 12, 2025 & 1.0 & Added Modules M1-M22\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \href{https://github.com/speech-buddies/VoiceBridge/blob/main/docs/SRS-Volere/SRS.pdf}{SRS}

\begin{tabular}{|l|l|}
\hline
\textbf{Acronym} & \textbf{Meaning} \\ \hline
DOM & Document Object Model \\ \hline
ARIA & Accessible Rich Internet Applications \\ \hline
\end{tabular}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} & Input Parameters\\
& Output Format\\
& Output Verification\\
& Temperature ODEs\\
& Energy Equations\\ 
& Control Module\\
& Specification Parameters Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& ODE Solver\\
& Plotting\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

% \section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
%   cross-referencing}

% \wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

% \wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\newpage
\section{MIS of User Interface Module} \label{M1}


\textbf{Module:} UserInterface

\subsection{Uses:}
\begin{itemize}
  \item Accessibility Layer (M2) to ensure UI semantics, ARIA roles, and announcements.
  \item Feedback Display Module (M3) to present messages, prompts, and recovery options.
  \item Intent Interpreter (M5) and Command Mapping (M6) for forwarding validated user events.
  \item BrowserController / rendering engine to perform DOM updates and capture input events.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{UserInterface} & \texttt{config: UiConfig} & self & InitializationError \\ \hline
\texttt{receiveInput} & \texttt{event: UiEvent} & - & \texttt{InputError} \\ \hline
\texttt{render} & \texttt{state: UiState} & - & RenderError \\ \hline
\texttt{showFeedback} & \texttt{msg: FeedbackItem} & - & - \\ \hline
\texttt{setFocus} & \texttt{elem\_id: string} & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{currentState}: \texttt{UiState} — current layout, visible components, and active feedback.
  \item \texttt{config}: \texttt{UiConfig} — persisted UI preferences (theme, verbosity).
  \item \texttt{focus\_target}: \texttt{string | null} — element currently targeted for keyboard/screen-reader focus.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{UI\_THEME} — runtime theme selection (light/dark).
  \item \texttt{LANG} — active locale.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Browser rendering engine and event APIs are available and conform to expected semantics.
  \item Downstream modules (M4–M6) accept events in the documented formats.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{UserInterface(config)}:
\begin{itemize}
\item \textbf{transition:} Initialize \texttt{currentState} and \texttt{config}; bind to Accessibility Layer (M2) and Feedback Display (M3).
\item \textbf{output:} Initialized UI instance.
\item \textbf{exception:} \texttt{InitializationError} if required resources are unavailable.
\end{itemize}

\noindent\texttt{receiveInput(event)}:
\begin{itemize}
\item \textbf{transition:} Validate \texttt{event}; update \texttt{currentState} or forward to Intent Interpreter (M5) / Command Mapping (M6) where appropriate.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{InputError} if \texttt{event} is malformed or unsupported.
\end{itemize}

\noindent\texttt{render(state)}:
\begin{itemize}
\item \textbf{transition:} Reconcile \texttt{currentState} with \texttt{state}; update DOM/renderer; notify Accessibility Layer (M2) of attribute changes.
\item \textbf{output:} -
\item \textbf{exception:} \texttt{RenderError} on failure.
\end{itemize}

\noindent\texttt{showFeedback(msg)}:
\begin{itemize}
  \item \textbf{transition:} Delegate presentation to Feedback Display Module (M3); ensure accessible announcement via Accessibility Layer (M2).
  \item \textbf{output:} -
  \item \textbf{exception:} -
\end{itemize}

\noindent\texttt{setFocus(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Set keyboard and screen-reader focus to element identified by \texttt{elem\_id}; update \texttt{focus\_target} state.
  \item \textbf{output:} -
  \item \textbf{exception:} \texttt{InputError} if \texttt{elem\_id} does not exist.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{apply\_config()} — Persist \texttt{config} and apply runtime settings.
  \item \texttt{normalize\_event(event)} — Normalize raw input events into \texttt{UiEvent} format.
\end{itemize}


\newpage
\section{MIS of Accessibility Layer} \label{M2}
\textbf{Module:} AccessibilityLayer

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to read and modify UI elements and attributes.
  \item WCAG guidance / accessibility utilities to verify contrast, labeling, and keyboard support.
  \item Feedback Display (M3) to coordinate announcements for user messages.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{AccessibilityLayer} & \texttt{parent: UserInterface} & self & - \\ \hline
\texttt{applySettings} & \texttt{settings: AccessConfig} & - & - \\ \hline
\texttt{announce} & \texttt{msg: string} & - & - \\ \hline
\texttt{validateElement} & \texttt{elem\_id: string} & \texttt{ValidationReport} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{settings: AccessConfig} — active accessibility options (font scale, contrast overrides, ARIA mappings).
  \item \texttt{live\_region\_id: string} — identifier for announcement region.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{WCAG\_LEVEL} — target conformance level (e.g., AA).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI (M1) exposes element identifiers and supports attribute updates.
  \item Localization resources exist for accessible labels when required.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{applySettings(settings)}:
\begin{itemize}
\item \textbf{transition:} Merge provided \texttt{settings} with defaults; apply text scaling, contrast adjustments, and ARIA attribute mappings via \texttt{parent}.
\item \textbf{output:} Boolean success status indicating whether settings were applied successfully.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{announce(msg)}:
\begin{itemize}
\item \textbf{transition:} Post \texttt{msg} to the live region and/or invoke screen-reader API for immediate announcement.
\item \textbf{output:} Confirmation token or status indicating the announcement was successfully scheduled or posted.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{validateElement(elem\_id)}:
\begin{itemize}
  \item \textbf{transition:} Inspect UI element attributes (role, label, states); compute a \texttt{ValidationReport} capturing compliance with accessibility standards.
  \item \textbf{output:} \texttt{ValidationReport} object detailing any missing roles, labels, or contrast issues.
  \item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{check\_contrast(rgb\_fg, rgb\_bg)} — Compute contrast ratio based on WCAG formula \(\frac{L_1 + 0.05}{L_2 + 0.05}\), where \(L_1\) and \(L_2\) are relative luminances of foreground and background; returns Boolean pass/fail against \texttt{WCAG\_LEVEL}.
  \item \texttt{aria\_set(elem\_id, metadata)} — Apply ARIA role, label, and state attributes to UI elements; returns Boolean indicating success.
\end{itemize}

\newpage
\section{MIS of Feedback Display Module}
\label{M3}

\textbf{Module:} FeedbackDisplay

\subsection{Uses:}
\begin{itemize}
  \item User Interface (M1) to render feedback content.
  \item Accessibility Layer (M2) to ensure feedback is announced to assistive technologies.
  \item Localization/configuration store for templated messages and user preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{FeedbackDisplay} & \texttt{parent: UserInterface} & self & - \\ \hline
\texttt{showMessage} & \texttt{msg: string}, \texttt{type: MsgType} & \texttt{feedbackId: UUID} & - \\ \hline
\texttt{clear} & - & - & - \\ \hline
\texttt{makeRecovery} & \texttt{feedbackId: UUID} & \texttt{RecoveryOptions} & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{messages: map[UUID] to FeedbackItem} — active feedback items keyed by id.
  \item \texttt{parent: UserInterface} — reference to UI for rendering.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Parent UI is capable of rendering message templates and interactive recovery prompts.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{FeedbackDisplay(parent)}:
\begin{itemize}
  \item \textbf{transition:} attach to \texttt{parent}; initialize \texttt{messages}.
  \item \textbf{output:} initialized feedback display instance.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{showMessage(msg, type)}:
\begin{itemize}
  \item \textbf{transition:} create \texttt{FeedbackItem}, store in \texttt{messages}, render via \texttt{parent}, and trigger Accessibility (M2) announcement if type requires.
  \item \textbf{output:} \texttt{feedbackId} for later reference.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{clear()}:
\begin{itemize}
  \item \textbf{transition:} remove all entries from \texttt{messages} and update UI.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{makeRecovery(feedbackId)}:
\begin{itemize}
  \item \textbf{transition:} build interactive recovery options (buttons, suggested actions) for the feedback item.
  \item \textbf{output:} \texttt{RecoveryOptions}.
  \item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{format\_message(msg, type)} — apply template, icons, and localization.
  \item \texttt{schedule\_dismiss(feedbackId, ttl\_s)} — auto-dismiss transient messages.
\end{itemize}

\newpage
\section{MIS of Speech-to-Text Engine}
\label{M4}

\textbf{Module:} SpeechToTextEngine

\subsection{Uses:}
\begin{itemize}
  \item Audio capture interface to receive microphone streams.
  \item Noise filtering and Voice Activity Detection (VAD) for preprocessing.
  \item Personalization/Profile store for per-user adaptation.
  \item Error Feedback (M8) and AuditLogger (M14) for reporting processing failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{SpeechToTextEngine} & \texttt{config: AsrConfig} & self & InitializationError \\ \hline
\texttt{processAudio} & \texttt{audioData: AudioStream} & \texttt{Transcript} & \texttt{ProcessingError} \\ \hline
\texttt{reset} & - & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{config: AsrConfig} — engine parameters (sample rate, frame size, thresholds).
  \item \texttt{model: AsrModel} — loaded acoustic/language models and decoder state.
  \item \texttt{audio\_buffer: AudioBuffer} — buffered input audio awaiting processing.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Input audio meets expected format and sample rate.
  \item Model artifacts are present and validated at initialization.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{SpeechToTextEngine(config)}:
\begin{itemize}
  \item \textbf{transition:} initialize engine internals, allocate \texttt{audio\_buffer}, and load \texttt{model}.
  \item \textbf{output:} initialized engine instance.
  \item \textbf{exception:} \texttt{InitializationError} if models or resources are missing.
\end{itemize}

\noindent\texttt{processAudio(audioData)}:
\begin{itemize}
  \item \textbf{transition:} preprocess (VAD, noise suppression), extract features, decode with models, and apply personalization.
  \item \textbf{output:} \texttt{Transcript} containing recognized text and confidence metadata.
  \item \textbf{exception:} \texttt{ProcessingError} on unrecoverable failure.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
  \item \textbf{transition:} clear \texttt{audio\_buffer} and reset decoder/model state.
  \item \textbf{output:} -.
  \item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{extract\_features(audio)} — compute model inputs (spectrogram, MFCCs).
  \item \texttt{decode(features)} — run acoustic and language decoding to produce candidate transcripts.
  \item \texttt{apply\_personalization(profile)} — adapt decoder priors using user profile.
\end{itemize}


\newpage
\section{MIS of Intent Interpreter}
\label{M5}

\textbf{Module:} IntentInterpreter

\subsection{Uses:}
\begin{itemize}
  \item Speech-to-Text Engine (M4) for input transcripts.
  \item Intent Schema Registry for parsing and intent extraction.
  \item Error Feedback (M8) for reporting ambiguous or failed interpretations.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{IntentInterpreter} & - & self & InitializationError \\ \hline
\texttt{interpret} & \texttt{transcript: Transcript} & \texttt{Intent} & \texttt{InterpretationError} \\ \hline
\texttt{reset} & - & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{intent\_schemas: IntentSchemaRegistry} — canonical intent definitions and slot schemas.
  \item \texttt{context: DialogContext} — context for multi-turn dialog and disambiguation.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Transcripts are syntactically valid and provide sufficient information for intent resolution in typical cases.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent\texttt{IntentInterpreter()}:
\begin{itemize}
    \item \textbf{Transition:} Load \texttt{intent\_schemas} and initialize \texttt{context} for dialog state.
    \item \textbf{Output:} Initialized interpreter instance ready to process transcripts.
    \item \textbf{Exception:} \texttt{InitializationError} if required schema resources are missing or invalid.
\end{itemize}


\noindent\texttt{interpret(transcript)}:
\begin{itemize}
\item \textbf{transition:} Parse input \texttt{transcript}; match it against intent schemas; extract and normalize slots; consult \texttt{context} for multi-turn resolution.
\item \textbf{output:} \texttt{Intent} object containing intent name, parameter slots, and confidence score.
\item \textbf{exception:} \texttt{InterpretationError} if no confident intent mapping can be produced.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
\item \textbf{transition:} Clear \texttt{context} and reset transient parsing caches.
\item \textbf{output:} Boolean flag indicating success of reset operation.
\item \textbf{exception:} -
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{match\_intent(text)} — score candidate intents and return best match.
  \item \texttt{extract\_slots(intent, text)} — extract and normalize parameter values for the matched intent.
\end{itemize}

\newpage
\section{MIS of Command Mapping Module}
\label{M6}

\textbf{Module:} CommandMapping

\subsection{Uses:}
\begin{itemize}
  \item Intent Interpreter (M5) for structured intents.
  \item Command Registry for available executable actions and metadata.
  \item User Preferences / Policy store to apply customization and guardrails.
  \item Error Feedback (M8) for reporting mapping or policy failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{CommandMapping} & - & self & InitializationError \\ \hline
\texttt{mapIntent} & \texttt{intent: Intent} & \texttt{Command} & \texttt{MappingError} \\ \hline
\texttt{validate} & \texttt{command: Command} & \texttt{bool} & - \\ \hline
\texttt{reset} & - & - & - \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{command\_registry: CommandRegistry} — available commands, parameter schemas, and metadata.
  \item \texttt{preferences: UserPreferences} — mapping rules and user-specific overrides.
  \item \texttt{policy: Policy} — mapping guardrails and authorization rules.
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item None.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Intent objects conform to the registered schema; command registry is current and authoritative.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\texttt{CommandMapping()}:
\begin{itemize}
  \item \textbf{transition:} Load \texttt{command\_registry}, \texttt{preferences}, and \texttt{policy} configurations.
  \item \textbf{output:} Initialized mapping instance ready to process intents.
  \item \textbf{exception:} \texttt{InitializationError} if registry or policy resources are missing or invalid.
\end{itemize}


\noindent\texttt{mapIntent(intent)}:
\begin{itemize}
\item \textbf{transition:} Select candidate commands matching the \texttt{intent}; apply \texttt{preferences} and enforce \texttt{policy} constraints; produce a validated \texttt{Command}.
\item \textbf{output:} Executable \texttt{Command} object representing the mapped device or browser action.
\item \textbf{exception:} \texttt{MappingError} if no suitable mapping exists or policy prevents execution.
\end{itemize}

\noindent\texttt{validate(command)}:
\begin{itemize}
\item \textbf{transition:} Execute guardrail checks (authorization, confirmation) against \texttt{command}.
\item \textbf{output:} \texttt{true} if \texttt{command} passes all validation criteria; otherwise \texttt{false}.
\item \textbf{exception:} -.
\end{itemize}

\noindent\texttt{reset()}:
\begin{itemize}
\item \textbf{transition:} Clear internal caches and reload default configuration.
\item \textbf{output:} Boolean indicating success of the reset operation.
\item \textbf{exception:} -.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{find\_command(intent)} — return candidate commands and ranking.
  \item \texttt{apply\_preferences(command)} — adapt parameters per user preferences.
  \item \texttt{enforce\_policy(command)} — apply policy and authorization constraints.
\end{itemize}


\newpage
\section{MIS of Command Execution Layer} \label{M7}

\subsection{Module}

Executes verified, mapped commands on the host device via the browser control bridge.
Responsible for dispatch, cancellation, basic guardrails, timeout handling, and result reporting.

\subsection{Uses}

Browser control/automation client (e.g., \texttt{BrowserUse} bridge); OS process APIs; timer utilities;
audit logger; configuration store for timeouts and retries.

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{CommandExecLayer} & \texttt{backend: Client}, \texttt{timeout\_s: int} & self & - \\
\texttt{execute} & \texttt{cmd: ExecCmd} & \texttt{Result} & \texttt{PermissionError}, \texttt{TimeoutError}, \texttt{ExecError} \\
\texttt{cancel} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{status} & \texttt{cmd\_id: UUID} & \texttt{ExecStatus} & \texttt{NotFoundError} \\
\texttt{validate} & \texttt{cmd: ExecCmd} & \texttt{bool} & - \\
\texttt{map\_to\_backend} & \texttt{cmd: ExecCmd} & \texttt{BackendReq} & \texttt{MappingError} \\
\texttt{rollback} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{ExecError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{pending\_q: map[UUID]$\to$ExecCtx} — commands in flight
  \item \texttt{default\_timeout\_s: int} — global timeout for executions
  \item \texttt{retries: int} — max retry attempts for transient failures
  \item \texttt{backend: Client} — handle to browser automation bridge
  \item \texttt{audit: Logger} — sink for execution logs
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{BROWSER\_BRIDGE\_URL} — connection string for automation client
  \item \texttt{EXEC\_HARD\_LIMIT\_S} — absolute upper bound on execution time
  \item \texttt{LOG\_LEVEL} — audit verbosity
\end{itemize}

\subsubsection{Assumptions}

\subsubsection{Access Routine Semantics}

\noindent

\noindent \texttt{CommandExecLayer}(\texttt{backend}, \texttt{timeout\_s}):
\begin{itemize}
\item transition: initialize \texttt{pending\_q}, set \texttt{default\_timeout\_s}, bind \texttt{backend}, configure \texttt{audit}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{execute}(\texttt{cmd}):
\begin{itemize}
\item transition: add to \texttt{pending\_q}; invoke \texttt{map\_to\_backend}; dispatch to \texttt{backend}; update status; remove on completion
\item output: \texttt{Result} with success flag, message, and optional payload
\item exception: \texttt{PermissionError} if disallowed; \texttt{TimeoutError} if exceeds limits; \texttt{ExecError} on backend failure
\end{itemize}

\noindent \texttt{cancel}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: signal cancellation to backend; mark context as cancelled; remove from \texttt{pending\_q}
\item output: \texttt{true} if cancelled; otherwise \texttt{false}
\item exception: \texttt{NotFoundError} if \texttt{cmd\_id} not tracked
\end{itemize}

\noindent \texttt{status}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: none
\item output: \texttt{ExecStatus} in \{\texttt{queued}, \texttt{running}, \texttt{succeeded}, \texttt{failed}, \texttt{cancelled}\}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{validate}(\texttt{cmd}):
\begin{itemize}
\item transition: none
\item output: \texttt{true} iff command matches allowed action set and guardrails (e.g., requires-confirmation flags met)
\item exception: -
\end{itemize}

\noindent \texttt{map\_to\_backend}(\texttt{cmd}):
\begin{itemize}
\item transition: none
\item output: \texttt{BackendReq} (normalized request for the bridge)
\item exception: \texttt{MappingError} if no mapping exists
\end{itemize}

\noindent \texttt{rollback}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: attempt compensating operation (e.g., reopen tab, revert text entry)
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{ExecError} if rollback fails
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{start\_timer(ctx)} — begin timeout tracking on a context
  \item \texttt{complete(ctx, result)} — finalize status, log, and cleanup
  \item \texttt{is\_allowed(cmd)} — check guardrails and policy
  \item \texttt{retryable(err)} — decide if backend error can be retried
  \item \texttt{to\_backend(payload)} — format request for bridge
\end{itemize}

\section{MIS of Error Feedback} \label{M8}

\subsection{Module}

Displays user-friendly error messages and recovery prompts. Surfaces execution issues, suggests next steps, and routes critical errors to support logs.

\subsection{Uses}

UI notification layer; audit logger; configuration store for messages; localization service (optional).

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ErrorFeedback} & \texttt{notifier: UiClient} & self & - \\
\texttt{show\_error} & \texttt{code: string}, \texttt{detail: string} & - & - \\
\texttt{show\_recovery} & \texttt{cmd\_id: UUID}, \texttt{options: string list} & - & - \\
\texttt{dismiss} & \texttt{feedback\_id: UUID} & \texttt{bool} & - \\
\texttt{log} & \texttt{event: ErrorEvent} & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{active: map[UUID] to FeedbackItem} — currently visible items
  \item \texttt{notifier: UiClient} — handle to UI notifications
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{DEFAULT\_LANG} — fallback locale
  \item \texttt{ERROR\_COPY\_PATH} — message templates location
\end{itemize}

\subsubsection{Assumptions}

UI client is available and permitted to display notifications.

\subsubsection{Access Routine Semantics}

\noindent \texttt{ErrorFeedback}(\texttt{notifier}):
\begin{itemize}
\item transition: initialize \texttt{active}; bind \texttt{notifier}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{show\_error}(\texttt{code}, \texttt{detail}):
\begin{itemize}
\item transition: create and register a feedback item in \texttt{active}; display via \texttt{notifier}
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{show\_recovery}(\texttt{cmd\_id}, \texttt{options}):
\begin{itemize}
\item transition: render recovery prompt with provided options
\item output: -
\item exception: -
\end{itemize}

\noindent \texttt{dismiss}(\texttt{feedback\_id}):
\begin{itemize}
\item transition: remove from \texttt{active}; instruct UI to hide
\item output: \texttt{true} if removed; otherwise \texttt{false}
\item exception: -
\end{itemize}

\noindent \texttt{log}(\texttt{event}):
\begin{itemize}
\item transition: write event to audit log
\item output: -
\item exception: -
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{format\_message(code, detail)} — produce a concise message
  \item \texttt{make\_recovery(options)} — build prompt content
\end{itemize}

\section{MIS of BrowserController} \label{M9}

\subsection{Module}

Handles interaction with the browser controller: sends backend requests, receives statuses, and streams results back to higher layers.

\subsection{Uses}

Browser automation bridge client; transport layer; timer utilities; audit logger.

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{BrowserController} & \texttt{bridge: Client}, \texttt{timeout\_s: int} & self & - \\
\texttt{send} & \texttt{req: BackendReq} & \texttt{BackendResp} & \texttt{TimeoutError}, \texttt{TransportError} \\
\texttt{get\_status} & \texttt{cmd\_id: UUID} & \texttt{ExecStatus} & \texttt{NotFoundError} \\
\texttt{cancel} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{open\_session} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{TransportError} \\
\texttt{close\_session} & \texttt{session\_id: SessionId} & \texttt{bool} & \texttt{TransportError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{bridge: Client} — transport to the browser controller
  \item \texttt{default\_timeout\_s: int} — call timeout
  \item \texttt{sessions: set[SessionId]} — open sessions
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{BROWSER\_BRIDGE\_URL} — endpoint for the controller
\end{itemize}

\subsubsection{Assumptions}

Controller endpoint is reachable and authenticated.

\subsubsection{Access Routine Semantics}

\noindent \texttt{BrowserController}(\texttt{bridge}, \texttt{timeout\_s}):
\begin{itemize}
\item transition: set \texttt{bridge}, \texttt{default\_timeout\_s}, clear \texttt{sessions}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{send}(\texttt{req}):
\begin{itemize}
\item transition: none
\item output: \texttt{BackendResp} from controller
\item exception: \texttt{TimeoutError}, \texttt{TransportError} on failures
\end{itemize}

\noindent \texttt{get\_status}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{ExecStatus}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{cancel}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: signal cancellation upstream
\item output: \texttt{true} if accepted
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{open\_session}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; add to \texttt{sessions}
\item output: \texttt{SessionId}
\item exception: \texttt{TransportError} if controller rejects
\end{itemize}

\noindent \texttt{close\_session}(\texttt{session\_id}):
\begin{itemize}
\item transition: close remotely; remove from \texttt{sessions}
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{TransportError} on failure
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{with\_timeout(call)} — wrap a bridge call with timeout
  \item \texttt{normalize(resp)} — normalize controller response
\end{itemize}
\section{MIS of Session Manager} \label{M10}

\subsection{Module}

Manages ongoing user sessions and their states: start, stop, track activity, and associate commands with sessions.

\subsection{Uses}

Persistent store or cache; clock utilities; audit logger.

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{SessionManager} & \texttt{store: Store}, \texttt{ttl\_s: int} & self & - \\
\texttt{start} & \texttt{user\_id: UUID} & \texttt{SessionId} & \texttt{StoreError} \\
\texttt{stop} & \texttt{session\_id: SessionId} & \texttt{bool} & \texttt{StoreError} \\
\texttt{get} & \texttt{session\_id: SessionId} & \texttt{SessionState} & \texttt{NotFoundError} \\
\texttt{attach\_command} & \texttt{session\_id: SessionId}, \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{NotFoundError} \\
\texttt{set\_state} & \texttt{session\_id: SessionId}, \texttt{state: SessionState} & \texttt{bool} & \texttt{StoreError} \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{store: Store} — persistence for sessions
  \item \texttt{ttl\_s: int} — idle expiry threshold
  \item \texttt{index: map[SessionId] to SessionState} — in-memory cache
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{SESSION\_TTL\_S} — default idle timeout
\end{itemize}

\subsubsection{Assumptions}

Store operations are atomic per session key.

\subsubsection{Access Routine Semantics}

\noindent \texttt{SessionManager}(\texttt{store}, \texttt{ttl\_s}):
\begin{itemize}
\item transition: set fields; warm cache from store if available
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{start}(\texttt{user\_id}):
\begin{itemize}
\item transition: create session; write to store; cache in \texttt{index}
\item output: \texttt{SessionId}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{stop}(\texttt{session\_id}):
\begin{itemize}
\item transition: mark closed; evict from \texttt{index}; update store
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{StoreError} on failure
\end{itemize}

\noindent \texttt{get}(\texttt{session\_id}):
\begin{itemize}
\item transition: none
\item output: current \texttt{SessionState}
\item exception: \texttt{NotFoundError} if unknown
\end{itemize}

\noindent \texttt{attach\_command}(\texttt{session\_id}, \texttt{cmd\_id}):
\begin{itemize}
\item transition: append command reference to session state
\item output: \texttt{true} if attached
\item exception: \texttt{NotFoundError} if session unknown
\end{itemize}

\noindent \texttt{set\_state}(\texttt{session\_id}, \texttt{state}):
\begin{itemize}
\item transition: update state in cache and store
\item output: \texttt{true} if updated
\item exception: \texttt{StoreError} on write failure
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{now()} — current timestamp
  \item \texttt{expired(state)} — checks idle expiry
\end{itemize}
\section{MIS of Error Handling \& Recovery Module} \label{M11}

\subsection{Module}

Classifies errors, applies retry and backoff policies, and coordinates recovery or compensation actions to return the system to a consistent state.

\subsection{Uses}

Policy store; timer/backoff utilities; audit logger; command execution layer; browser controller.

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{ErrorHandler} & \texttt{policy: Policy} & self & - \\
\texttt{handle} & \texttt{err: ExecError}, \texttt{ctx: ExecCtx} & \texttt{ActionResult} & - \\
\texttt{retry} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{PolicyError} \\
\texttt{compensate} & \texttt{cmd\_id: UUID} & \texttt{bool} & \texttt{ExecError} \\
\texttt{classify} & \texttt{err: ExecError} & \texttt{ErrorClass} & - \\
\texttt{record} & \texttt{err: ExecError}, \texttt{ctx: ExecCtx} & \texttt{UUID} & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{policy: Policy} — retry and compensation rules
  \item \texttt{history: map[UUID] to ErrorEvent} — recent errors
  \item \texttt{backoff: map[UUID] to int} — current backoff in seconds
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{MAX\_RETRIES} — hard cap for attempts
  \item \texttt{BASE\_BACKOFF\_S} — initial delay
\end{itemize}

\subsubsection{Assumptions}

Compensation actions are idempotent or guarded.

\subsubsection{Access Routine Semantics}

\noindent \texttt{ErrorHandler}(\texttt{policy}):
\begin{itemize}
\item transition: set \texttt{policy}; clear \texttt{history}, \texttt{backoff}
\item output: initialized instance
\item exception: -
\end{itemize}

\noindent \texttt{handle}(\texttt{err}, \texttt{ctx}):
\begin{itemize}
\item transition: classify; decide action (retry, compensate, fail); update \texttt{history}, \texttt{backoff}
\item output: \texttt{ActionResult} describing action taken
\item exception: -
\end{itemize}

\noindent \texttt{retry}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: schedule retry with policy backoff
\item output: \texttt{true} if scheduled
\item exception: \texttt{PolicyError} if retries exhausted
\end{itemize}

\noindent \texttt{compensate}(\texttt{cmd\_id}):
\begin{itemize}
\item transition: execute compensation; update state
\item output: \texttt{true} on success; otherwise \texttt{false}
\item exception: \texttt{ExecError} if compensation fails
\end{itemize}

\noindent \texttt{classify}(\texttt{err}):
\begin{itemize}
\item transition: none
\item output: \texttt{ErrorClass} such as transient, permanent, or user
\item exception: -
\end{itemize}

\noindent \texttt{record}(\texttt{err}, \texttt{ctx}):
\begin{itemize}
\item transition: persist error event; update \texttt{history}
\item output: event identifier \texttt{UUID}
\item exception: -
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \texttt{calc\_backoff(cmd\_id)} — compute next delay
  \item \texttt{is\_idempotent(cmd\_id)} — check compensation safety
\end{itemize}

\section{MIS of Storage Management Module  --- M12}
\label{MIS:M12}

\textbf{Module:} Storage Management Module 

\subsection{Uses:}
\begin{itemize}
  \item Encryption Manager (M16) for encryption/decryption at rest and in transit (R16.3).
  \item Credential Manager (M15) for authenticated access to user-specific data (R16.1).
  \item AuditLogger (M14) to record storage and retrieval events (R16.4).
  \item UserProfileManager (M13) for storing personalized ASR profiles and preferences.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Constants:}
\begin{itemize}
  \item \texttt{MAX\_STORAGE\_LIMIT} = 5GB per user session (configurable).
  \item \texttt{BACKUP\_INTERVAL} = 24 hours.
  \item \texttt{RETENTION\_PERIOD} = 90 days (per R16.3 Privacy Requirements).
\end{itemize}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{storeTranscript} & transcriptData, userID & confirmationID & StorageWriteException \\ \hline
\texttt{retrieveTranscript} & transcriptID, userID & transcriptData & DataNotFoundException \\ \hline
\texttt{backupData} & userID & backupStatus & BackupFailureException \\ \hline
\texttt{enforceRetentionRules} & policyConfig & summaryReport & RetentionException \\ \hline
\end{tabular}

\subsection{Semantics}
\subsubsection{State Variables:}
\begin{itemize}
  \item \texttt{storageRegistry}: maps user data identifiers to file metadata and encryption state.
  \item \texttt{backupSchedule}: list of active backups per user.
  \item \texttt{retentionPolicies}: retention rules derived from privacy configuration (R16.3).
\end{itemize}

\subsubsection{Environment Variables:}
\begin{itemize}
  \item \texttt{DATABASE\_URL}: location of secure storage database.
  \item \texttt{CLOUD\_STORAGE\_API}: API endpoint for encrypted cloud backups.
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
  \item Encryption Manager (M16) is available for encrypting all stored data.
  \item User authentication is validated by Credential Manager (M15) before access.
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{storeTranscript(transcriptData, userID)}:
\begin{itemize}
  \item \textbf{transition:} Adds a new entry to \texttt{storageRegistry}, encrypts transcript data via M16, and logs the event via M14.
  \item \textbf{output:} Returns confirmation ID.
  \item \textbf{exception:} \texttt{StorageWriteException} if quota exceeded or encryption fails.
\end{itemize}

\noindent\texttt{retrieveTranscript(transcriptID, userID)}:
\begin{itemize}
  \item \textbf{output:} Returns decrypted transcript data.
  \item \textbf{exception:} \texttt{DataNotFoundException} if transcriptID not found or access denied.
\end{itemize}

\noindent\texttt{backupData(userID)}:
\begin{itemize}
  \item \textbf{transition:} Performs encrypted backup of stored data to cloud (per R16.3).
  \item \textbf{output:} Backup status (success/failure).
\end{itemize}

\noindent\texttt{enforceRetentionRules(policyConfig)}:
\begin{itemize}
  \item \textbf{transition:} Deletes expired or policy-violating entries from storage.
  \item \textbf{output:} Summary of removed or archived files.
\end{itemize}

\subsubsection{Local Functions:}
\begin{itemize}
  \item \texttt{verifyBackupIntegrity(backupID)}
  \item \texttt{applyRetentionRule(fileMeta)}
\end{itemize}

\section{MIS of User Profile Manager --- M13}

\textbf{Module:} UserProfileManager

\subsection{Uses:}
\begin{itemize}
\item Credential Manager (M15) for token validation and secure login (R16.1).
\item Encryption Manager (M16) for encrypting stored profiles (R16.3).
\item Storage Management Module (M12) for persistence.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{createProfile} & userToken, initData & profileID & ProfileCreationException \\ \hline
\texttt{loadPreferences} & userID & preferenceData & DataNotFoundException \\ \hline
\texttt{saveConsent} & userID, consentFlags & status & ConsentException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{State Variables:}
\begin{itemize}
\item \texttt{profiles}: map of userID → profile metadata.
\item \texttt{preferences}: user personalization data (R12.2).
\item \texttt{consentLog}: record of consent actions (R16.3).
\end{itemize}

\subsubsection{Assumptions:}
\begin{itemize}
\item Consent is required prior to storing personalization data (R16.3 Privacy).
\end{itemize}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{createProfile(userToken, initData)}:
\begin{itemize}
\item \textbf{transition:} Creates encrypted user profile and saves to M12 storage.
\item \textbf{exception:} \texttt{ProfileCreationException} on invalid token.
\end{itemize}

\noindent\texttt{saveConsent(userID, consentFlags)}:
\begin{itemize}
\item \textbf{transition:} Updates consentLog.
\item \textbf{output:} Confirmation of saved consent (R16.3).
\end{itemize}


\section{MIS of AuditLogger --- M14}

\textbf{Module:} AuditLogger

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M16) for log encryption.
\item Credential Manager (M15) for secure log access.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{logEvent} & eventData, severity & logID & LogWriteException \\ \hline
\texttt{queryLogs} & filterParams, userRole & logRecords & UnauthorizedAccessException \\ \hline
\texttt{detectAnomaly} & recentLogs & anomalyReport & DetectionException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{logEvent(eventData, severity)}:
\begin{itemize}
\item \textbf{transition:} Writes signed and encrypted log entry per R16.4.
\end{itemize}

\noindent\texttt{detectAnomaly(recentLogs)}:
\begin{itemize}
\item \textbf{output:} Triggers OutOfScopeHandler (M17) on suspicious events.
\end{itemize}


\label{MIS:M15}

\section{MIS of Credential Manager --- M15}

\textbf{Module:} Credential Manager (CredentialManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item Encryption Manager (M16) for secure key storage.
\item AuditLogger (M14) to record authentication attempts (R16.4).
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{authenticateUser} & username, password & sessionToken & AuthException \\ \hline
\texttt{validateToken} & sessionToken & validity & TokenException \\ \hline
\texttt{rotateKeys} & scheduleID & status & KeyRotationException \\ \hline
\end{tabular}

\subsection{Semantics}

\subsubsection{Access Routine Semantics:}

\noindent\texttt{authenticateUser(username, password)}:
\begin{itemize}
\item \textbf{transition:} Validates credentials via password vault; issues signed token (R16.1).
\end{itemize}

\noindent\texttt{rotateKeys(scheduleID)}:
\begin{itemize}
\item \textbf{transition:} Calls M16 to rotate key pairs per R16.3.
\end{itemize}


\label{MIS:M16}

\section{MIS of Encryption Manager --- M16}

\textbf{Module:} Encryption Manager (EncryptionManagerImpl)

\subsection{Uses:}
\begin{itemize}
\item None — foundational security service.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{encryptData} & plainData, keyID & cipherData & EncryptionException \\ \hline
\texttt{decryptData} & cipherData, keyID & plainData & DecryptionException \\ \hline
\texttt{rotateKeys} & rotationPolicy & result & RotationFailureException \\ \hline
\texttt{verifyIntegrity} & dataBlob, signature & validFlag & IntegrityException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.3 (Privacy Requirements): ensures all data is encrypted at rest/in transit.
Implements R16.2 (Integrity): validates message hashes before use.


\label{MIS:M17}

\section{MIS of OutOfScopeHandler --- M17}

\textbf{Module:} OutOfScopeHandler

\subsection{Uses:}
\begin{itemize}
\item AuditLogger (M14) for incident reporting (R16.4).
\item Command Mapping Module (M6) for validation of user commands.
\item Error Handling \& Recovery (M11) for rollback actions.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{validateCommand} & commandText, context & validationResult & InvalidCommandException \\ \hline
\texttt{reportIncident} & incidentData & reportID & ReportFailureException \\ \hline
\texttt{recoverState} & sessionID & status & RecoveryException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements R16.5 (Immunity Requirements): ensures robustness against unsafe operations.
Integrates with M14 to log anomaly-triggered safety events.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{validateCommand(commandText)}:
\begin{itemize}
\item \textbf{transition:} Compares command against whitelist (policy from config).
\end{itemize}

\noindent\texttt{recoverState(sessionID)}:
\begin{itemize}
\item \textbf{transition:} Restores safe prior system state through M11.
\end{itemize}

\label{MIS:M18}

\section{MIS of MicrophoneManager --- M18}

\textbf{Module:} MicrophoneManager

\subsection{Uses:}
\begin{itemize}
\item VAD Noise Filter (M19) for downstream speech/noise classification.
\item Session Manager (M10) for tracking active input sessions.
\item AuditLogger (M14) for logging permission events or device failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{listDevices} & - & deviceList & DeviceQueryException \\ \hline
\texttt{startCapture} & deviceID & status & PermissionException \\ \hline
\texttt{readFrame} & - & audioFrame & CaptureInactiveException \\ \hline
\end{tabular}

\subsection{Semantics}

Implements audio acquisition requirements (FR1). Provides consistent, normalized microphone
input to subsequent modules. Integrates with M10 to maintain session continuity.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{startCapture(deviceID)}:
\begin{itemize}
\item \textbf{transition:} Initializes device stream and marks microphone as active.
\end{itemize}

\noindent\texttt{readFrame()}:
\begin{itemize}
\item \textbf{transition:} Retrieves the latest audio frame for processing.
\end{itemize}

\label{MIS:M19}

\section{MIS of VADNoiseFilter --- M19}

\textbf{Module:} VADNoiseFilter

\subsection{Uses:}
\begin{itemize}
\item MicrophoneManager (M18) for raw audio frames.
\item Speech-to-Text Engine (M4) for improved transcription accuracy.
\item AuditLogger (M14) for tracking confidence drops or noise anomalies.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{filterFrame} & audioFrame & cleanedFrame & - \\ \hline
\texttt{detectSpeech} & audioFrame & isSpeech (bool) & - \\ \hline
\texttt{resetState} & - & status & - \\ \hline
\end{tabular}

\subsection{Semantics}

Supports Integrity Requirements (IR2) by reducing background noise prior to transcription.
Provides binary VAD detections for downstream timing and segmentation.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{filterFrame(frame)}:
\begin{itemize}
\item \textbf{transition:} Updates internal noise profile and returns processed audio.
\end{itemize}

\noindent\texttt{detectSpeech(frame)}:
\begin{itemize}
\item \textbf{transition:} Computes speech probability using configured thresholds.
\end{itemize}

\label{MIS:M20}

\section{MIS of PromptingModule --- M20}

\textbf{Module:} PromptingModule

\subsection{Uses:}
\begin{itemize}
\item Intent Interpreter (M5) for phrasing confirmations.
\item Error Feedback (M8) for generating user-facing explanations.
\item Accessibility Layer (M2) for formatting prompts according to accessibility rules.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{makePrompt} & uiState & promptText & - \\ \hline
\texttt{makeConfirm} & intent & promptText & - \\ \hline
\texttt{makeErrorPrompt} & errorData & promptText & - \\ \hline
\end{tabular}

\subsection{Semantics}

Supports usability requirements (UH-1, UH-4) and cultural neutrality (CUL-1).
Ensures consistent phrasing across confirmations, errors, and system messages.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{makeConfirm(intent)}:
\begin{itemize}
\item \textbf{transition:} Constructs a confirmation string based on target action.
\end{itemize}

\noindent\texttt{makeErrorPrompt(errorData)}:
\begin{itemize}
\item \textbf{transition:} Builds a polite, accessible error message.
\end{itemize}

\label{MIS:M21}

\section{MIS of ModelTuner --- M21}

\textbf{Module:} ModelTuner

\subsection{Uses:}
\begin{itemize}
\item Data Management Layer (M12) for retrieving stored audio samples.
\item ASR Engine (M4) for updating recognition parameters.
\item AuditLogger (M14) for recording tuning events or failures.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{scheduleTune} & userID, dataset & jobID & TunePolicyException \\ \hline
\texttt{checkStatus} & jobID & status & NotFoundException \\ \hline
\texttt{applyModel} & userID, jobID & success (bool) & ModelLoadException \\ \hline
\end{tabular}

\subsection{Semantics}

Supports Accuracy Requirements (PF-3) by enabling adaptive personalization for impaired speech.
Updates the user's model profile upon successful tuning.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{scheduleTune(userID, dataset)}:
\begin{itemize}
\item \textbf{transition:} Registers a tuning job with the training backend.
\end{itemize}

\noindent\texttt{applyModel(userID, jobID)}:
\begin{itemize}
\item \textbf{transition:} Loads and activates the newly tuned ASR parameters.
\end{itemize}

\label{MIS:M22}

\section{MIS of InstructionRegistry --- M22}

\textbf{Module:} InstructionRegistry

\subsection{Uses:}
\begin{itemize}
\item Command Mapping Module (M6) for resolving intent-to-command mappings.
\item Data Management Layer (M12) for persistent storage of registered instructions.
\item AuditLogger (M14) for tracking updates to command schemas.
\end{itemize}

\subsection{Syntax:}

\subsubsection{Exported Access Programs:}

\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ \hline
\texttt{lookup} & intent & instruction & NotFoundException \\ \hline
\texttt{registerInstr} & instruction & status & StoreException \\ \hline
\texttt{updateInstr} & id, instruction & status & StoreException \\ \hline
\end{tabular}

\subsection{Semantics}

Supports command mapping requirements (FR4) and safety guardrails (SEC-2).
Maintains the authoritative index of allowed command definitions.

\subsubsection{Access Routine Semantics:}

\noindent\texttt{lookup(intent)}:
\begin{itemize}
\item \textbf{transition:} Retrieves matching instruction from registry.
\end{itemize}

\noindent\texttt{updateInstr(id, instruction)}:
\begin{itemize}
\item \textbf{transition:} Overwrites stored schema with the updated definition.
\end{itemize}










\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}